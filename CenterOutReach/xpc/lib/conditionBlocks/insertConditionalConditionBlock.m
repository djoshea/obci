function Cnew = insertConditionalConditionBlock(C, ...
    conditionMatch, paramValueListsMatch, ...
    varargin)
% C is generated by generateConditionBlockFromRelativeFrequencies.
% 
% This function appends additional condition fields to the paramValueTable,
% by separately expanding paramValueListsMatch (much like
% generateConditionBlockFromRelativeFrequencies does) for each condition for which
% the values specified in conditionMatch match that condition.
% 
% for conditionMatch.field = scalar, the paramValueTable.field must ==
% scalar, whereas for conditionMatch.field == [vector],
% paramValueTable.field must be a member of vector.
%
% Non-matching conditions will be left alone, and the added fields will
% have empty values.
%
% If preserveRelativeFrequencies is true (default), the repeat counts for
% the table will be set such that the relative frequencies specified for
% fields in conditionMatch will be mainained. 
% Example: suppose conditionMatch.field = 1, and paramValueTable was generated with
% field having values [0 1] with relative frequencies [1 1]. Suppose 
% paramValueListsMatch.newField = [true false] and
% paramRelativeFrequenciesMatch.newField = [1 1]. 
%
% With preserveRelativeFrequencies = true. The paramValueTable and
% conditionRepeats will look like:
%   .field = 0, .newField = [],    repeats = 2
%   .field = 1, .newField = true,  repeats = 1
%   .field = 1, .newField = false, repeats = 1
%
% On the other hand, if  preserveRelativeFrequencies = false, 
% the paramValueTable and conditionRepeats will look like:
%   .field = 0, .newField = [],    repeats = 1
%   .field = 1, .newField = true,  repeats = 1
%   .field = 1, .newField = false, repeats = 1
% i.e. the "new conditions" will be added, duplicating the original, 
% replaced condition.
% 
% Author: Dan O'Shea (c) 2014 dan { at } REMOVETHISdjoshea.com
%

    p = inputParser();
    p.addOptional('paramRelativeFrequenciesMatch', [], @(x) isstruct(x) || isempty(x));
    p.addOptional('paramValuesNonMatch', [], @(x) isstruct(x) || isempty(x));
    p.addParamValue('preserveRelativeFrequencies', true, @islogical);
    p.parse(varargin{:});

    paramRelativeFrequenciesMatch = p.Results.paramRelativeFrequenciesMatch;
    paramValuesNonMatch = p.Results.paramValuesNonMatch;
    preserveRelativeFrequencies = p.Results.preserveRelativeFrequencies;

    paramValueTable = rmfield(C, {'conditionId', 'conditionRepeats'});
    conditionRepeats = makecol([C.conditionRepeats]);   

    % expand the new fields table
    [pvTableMatch, conditionRepsMatch] = ...
        generateConditionBlockFromRelativeFrequencies(paramValueListsMatch, ...
        paramRelativeFrequenciesMatch);
    pvTableMatch = rmfield(pvTableMatch, {'conditionId', 'conditionRepeats'});

    totalNewReps = sum(conditionRepsMatch);

    nOldTable = numel(paramValueTable);

    % collect the new struct pieces to be concatenated later
    newTableCell = cell(nOldTable, 1);
    newConditionRepsCell = cell(nOldTable, 1);
    newFields = fieldnames(pvTableMatch);

    % populate the default empty values for paramValuesNonMatch
    if isempty(paramValuesNonMatch)
        paramValuesNonMatch = struct();
        for iF = 1:numel(newFields)
            fld = newFields{iF};
            paramValuesNonMatch.(fld) = [];
        end
    end
    
    % which paramValueTable(:) meet the criteria of conditionMatch?
    matches = matchesFilter(paramValueTable, conditionMatch);

    % loop over each condition in the old table
    for iE = 1:nOldTable
        row = paramValueTable(iE);

        if ~matches(iE)
            % not a match, just use the original table row, with added empty
            % fields
            newTableCell{iE} = paramValueTable(iE);
            for iF = 1:numel(newFields)
                fld = newFields{iF};
                if isfield(paramValuesNonMatch, fld) && ~isempty(paramValuesNonMatch.(fld))
                    % don't store the value if not specified
                    temp = paramValuesNonMatch.(fld);
                    if isa(temp, 'function_handle') % eval if function handle 
                        temp = temp(row);
                    end
                        
                    newTableCell{iE}.(fld) = temp;
                end
            end

            % scale the condition repeats if requested
            if preserveRelativeFrequencies
                newConditionRepsCell{iE} = conditionRepeats(iE) * totalNewReps;
            else
                newConditionRepsCell{iE} = conditionRepeats(iE);
            end
        else
            % is a match, replace original table row with expanded table
            table = repmat(paramValueTable(iE), numel(pvTableMatch), 1);

            % substitute in each of the new table rows
            for iF = 1:numel(newFields)
                fld = newFields{iF};
                vals = {pvTableMatch.(fld)};
                  
                for iT = 1:numel(table)
                    val = vals{iT};
                    if isa(val, 'function_handle') % eval if function handle
                        val = val(table(iT));
                    end
                    table(iT).(fld) = val;
                end
            end
            
            newTableCell{iE} = table;

%             if preserveRelativeFrequencies
%                 newConditionRepsCell{iE} = repmat(totalNewReps * conditionRepeats(iE), numel(table), 1);
%             else
                newConditionRepsCell{iE} = double(conditionRepeats(iE)) * conditionRepsMatch;
%             end
        end
    end

    paramValueTable = cat(1, newTableCell{:});
    conditionRepeats = cat(1, newConditionRepsCell{:});
    conditionRepeats = conditionRepeats / gcdvec(conditionRepeats);

    Cnew = paramValueTable;
    for iC = 1:numel(Cnew)
        Cnew(iC).conditionId = uint16(iC);
        Cnew(iC).conditionRepeats = uint16(conditionRepeats(iC));
    end
end

function tf = matchesFilter(test, filter)
    % test and filter are both struct arrays,
    % tf(i) is true if ismember(test.field, filter.field) for all
    % field = fieldnames(filter)
    
    tf = true(numel(test), 1);
    flds = fieldnames(filter);
    for iT = 1:numel(test)
        for iF = 1:numel(flds)
            fld = flds{iF};
            tf(iT) = tf(iT) && ismember(test(iT).(fld), filter.(fld));
        end
    end
end 
        
function c = makecol(in)
    c = in(:);
end

function g = gcdvec(in)
% compute the gcd of a vector of numbers
    if numel(in) > 2
        g = gcd(in(1), gcdvec(in(2:end)));
    elseif numel(in) == 2
        g = gcd(in(1), in(2));
    else
        g = in;
    end
    
end
