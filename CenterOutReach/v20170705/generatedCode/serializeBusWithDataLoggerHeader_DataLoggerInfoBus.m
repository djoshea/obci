function [out, valid] = serializeBusWithDataLoggerHeader_DataLoggerInfoBus(bus, groupType, groupName, timestamp, namePrefix)
%#codegen
% DO NOT EDIT: Auto-generated by 
%   BusSerialize.writeSerializeBusCode('DataLoggerInfoBus')

    if nargin < 5, namePrefix = uint8(''); end
    namePrefixBytes = uint8(namePrefix(:))';
    valid = uint8(0);
    headerLength = uint32(BusSerialize.computeDataLoggerHeaderLength(uint8([namePrefixBytes, groupName])));
    coder.varsize('out', 206 + 5*numel(namePrefix) + headerLength);
    outSize = headerLength + getSerializedBusLength_DataLoggerInfoBus(bus, namePrefix);
    assert(outSize <= headerLength + 206 + 5*numel(namePrefix));
    out = zeros(outSize, 1, 'uint8');
    offset = uint32(1);

    % Serialize data logger header
    header = BusSerialize.serializeDataLoggerHeader(groupType, uint8([namePrefixBytes, groupName]), uint32(715523848), uint16(5), timestamp);
    out(1:headerLength) = uint8(header);
    offset = offset + headerLength;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized dataStore
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.dataStore) <= 30, 'numel(bus.dataStore) exceeds max size of 30');    % dataStore bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);

    % dataStore signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % dataStore name with prefix 
    if(offset+uint32(2+9 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 9), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 9-1))) = [namePrefixBytes, uint8('dataStore')];
    offset = offset + uint32(numel(namePrefixBytes) + 9);

    % dataStore units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('char');
    offset = offset + uint32(4);

    % dataStore data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is char
    offset = offset + uint32(1);

    % dataStore dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.dataStore)), 'uint8');
    offset = offset + uint32(2*1);

    % dataStore data
    nBytes = uint32(1 * numel(bus.dataStore));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.dataStore(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized subject
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.subject) <= 30, 'numel(bus.subject) exceeds max size of 30');    % subject bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);

    % subject signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % subject name with prefix 
    if(offset+uint32(2+7 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 7), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 7-1))) = [namePrefixBytes, uint8('subject')];
    offset = offset + uint32(numel(namePrefixBytes) + 7);

    % subject units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('char');
    offset = offset + uint32(4);

    % subject data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is char
    offset = offset + uint32(1);

    % subject dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.subject)), 'uint8');
    offset = offset + uint32(2*1);

    % subject data
    nBytes = uint32(1 * numel(bus.subject));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.subject(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized protocol
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.protocol) <= 30, 'numel(bus.protocol) exceeds max size of 30');    % protocol bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);

    % protocol signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % protocol name with prefix 
    if(offset+uint32(2+8 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 8), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 8-1))) = [namePrefixBytes, uint8('protocol')];
    offset = offset + uint32(numel(namePrefixBytes) + 8);

    % protocol units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('char');
    offset = offset + uint32(4);

    % protocol data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is char
    offset = offset + uint32(1);

    % protocol dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.protocol)), 'uint8');
    offset = offset + uint32(2*1);

    % protocol data
    nBytes = uint32(1 * numel(bus.protocol));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.protocol(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized protocolVersion
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.protocolVersion) == 1, 'numel(bus.protocolVersion) must be 1');    % protocolVersion bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % protocolVersion signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % protocolVersion name with prefix 
    if(offset+uint32(2+15 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 15), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 15-1))) = [namePrefixBytes, uint8('protocolVersion')];
    offset = offset + uint32(numel(namePrefixBytes) + 15);

    % protocolVersion units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % protocolVersion data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % protocolVersion dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.protocolVersion)), 'uint8');
    offset = offset + uint32(2*1);

    % protocolVersion data
    nBytes = uint32(4 * numel(bus.protocolVersion));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.protocolVersion(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized saveTag
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.saveTag) == 1, 'numel(bus.saveTag) must be 1');    % saveTag bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % saveTag signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % saveTag name with prefix 
    if(offset+uint32(2+7 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 7), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 7-1))) = [namePrefixBytes, uint8('saveTag')];
    offset = offset + uint32(numel(namePrefixBytes) + 7);

    % saveTag units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % saveTag data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % saveTag dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.saveTag)), 'uint8');
    offset = offset + uint32(2*1);

    % saveTag data
    nBytes = uint32(4 * numel(bus.saveTag));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.saveTag(:))', 'uint8')';
    end
    offset = offset + nBytes; %#ok<NASGU>

    valid = uint8(1);
end