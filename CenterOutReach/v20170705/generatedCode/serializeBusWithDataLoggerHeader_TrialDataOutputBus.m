function [out, valid] = serializeBusWithDataLoggerHeader_TrialDataOutputBus(bus, groupType, groupName, timestamp, namePrefix)
%#codegen
% DO NOT EDIT: Auto-generated by 
%   BusSerialize.writeSerializeBusCode('TrialDataOutputBus')

    if nargin < 5, namePrefix = uint8(''); end
    namePrefixBytes = uint8(namePrefix(:))';
    valid = uint8(0);
    headerLength = uint32(BusSerialize.computeDataLoggerHeaderLength(uint8([namePrefixBytes, groupName])));
    coder.varsize('out', 419 + 15*numel(namePrefix) + headerLength);
    outSize = headerLength + getSerializedBusLength_TrialDataOutputBus(bus, namePrefix);
    assert(outSize <= headerLength + 419 + 15*numel(namePrefix));
    out = zeros(outSize, 1, 'uint8');
    offset = uint32(1);

    % Serialize data logger header
    header = BusSerialize.serializeDataLoggerHeader(groupType, uint8([namePrefixBytes, groupName]), uint32(937972890), uint16(15), timestamp);
    out(1:headerLength) = uint8(header);
    offset = offset + headerLength;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized rt
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.rt) == 1, 'numel(bus.rt) must be 1');    % rt bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % rt signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % rt name with prefix 
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 2-1))) = [namePrefixBytes, uint8('rt')];
    offset = offset + uint32(numel(namePrefixBytes) + 2);

    % rt units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % rt data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % rt dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.rt)), 'uint8');
    offset = offset + uint32(2*1);

    % rt data
    nBytes = uint32(4 * numel(bus.rt));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.rt(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized delay
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.delay) == 1, 'numel(bus.delay) must be 1');    % delay bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % delay signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % delay name with prefix 
    if(offset+uint32(2+5 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 5), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 5-1))) = [namePrefixBytes, uint8('delay')];
    offset = offset + uint32(numel(namePrefixBytes) + 5);

    % delay units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % delay data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % delay dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.delay)), 'uint8');
    offset = offset + uint32(2*1);

    % delay data
    nBytes = uint32(4 * numel(bus.delay));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.delay(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized iti
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.iti) == 1, 'numel(bus.iti) must be 1');    % iti bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % iti signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % iti name with prefix 
    if(offset+uint32(2+3 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 3), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 3-1))) = [namePrefixBytes, uint8('iti')];
    offset = offset + uint32(numel(namePrefixBytes) + 3);

    % iti units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % iti data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % iti dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.iti)), 'uint8');
    offset = offset + uint32(2*1);

    % iti data
    nBytes = uint32(4 * numel(bus.iti));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.iti(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized success
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.success) == 1, 'numel(bus.success) must be 1');    % success bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % success signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % success name with prefix 
    if(offset+uint32(2+7 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 7), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 7-1))) = [namePrefixBytes, uint8('success')];
    offset = offset + uint32(numel(namePrefixBytes) + 7);

    % success units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % success data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % success dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.success)), 'uint8');
    offset = offset + uint32(2*1);

    % success data
    nBytes = uint32(1 * numel(bus.success));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.success(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized substantiveFailure
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.substantiveFailure) == 1, 'numel(bus.substantiveFailure) must be 1');    % substantiveFailure bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % substantiveFailure signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % substantiveFailure name with prefix 
    if(offset+uint32(2+18 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 18), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 18-1))) = [namePrefixBytes, uint8('substantiveFailure')];
    offset = offset + uint32(numel(namePrefixBytes) + 18);

    % substantiveFailure units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % substantiveFailure data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % substantiveFailure dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.substantiveFailure)), 'uint8');
    offset = offset + uint32(2*1);

    % substantiveFailure data
    nBytes = uint32(1 * numel(bus.substantiveFailure));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.substantiveFailure(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized failureCode
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.failureCode) == 1, 'numel(bus.failureCode) must be 1');    % failureCode bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(0);
    offset = offset + uint32(1);

    % failureCode signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % failureCode name with prefix 
    if(offset+uint32(2+11 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 11), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 11-1))) = [namePrefixBytes, uint8('failureCode')];
    offset = offset + uint32(numel(namePrefixBytes) + 11);

    % failureCode units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('enum');
    offset = offset + uint32(4);

    % failureCode data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is TaskState
    offset = offset + uint32(1);

    % failureCode dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    % converting enum type TaskState to string
    coder.varsize('enumAsStr_failureCode', 22);
    enumAsStr_failureCode = zeros(0, 1, 'uint8');
    for iEnum = 1:numel(bus.failureCode)
        enumAsStr_failureCode = [enumAsStr_failureCode; uint8(enumToString_TaskState(bus.failureCode(iEnum)))']; %#ok<AGROW>
        if iEnum < numel(bus.failureCode)
            enumAsStr_failureCode = [enumAsStr_failureCode; uint8(';')]; %#ok<AGROW>
        end
    end
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(enumAsStr_failureCode)), 'uint8');
    offset = offset + uint32(2*1);

    % failureCode data
    nBytes = uint32(numel(enumAsStr_failureCode));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(enumAsStr_failureCode(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized consecutiveNoStarts
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.consecutiveNoStarts) == 1, 'numel(bus.consecutiveNoStarts) must be 1');    % consecutiveNoStarts bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % consecutiveNoStarts signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % consecutiveNoStarts name with prefix 
    if(offset+uint32(2+19 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 19), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 19-1))) = [namePrefixBytes, uint8('consecutiveNoStarts')];
    offset = offset + uint32(numel(namePrefixBytes) + 19);

    % consecutiveNoStarts units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % consecutiveNoStarts data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(5); % data type is uint16
    offset = offset + uint32(1);

    % consecutiveNoStarts dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.consecutiveNoStarts)), 'uint8');
    offset = offset + uint32(2*1);

    % consecutiveNoStarts data
    nBytes = uint32(2 * numel(bus.consecutiveNoStarts));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint16(bus.consecutiveNoStarts(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized inPurgatory
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.inPurgatory) == 1, 'numel(bus.inPurgatory) must be 1');    % inPurgatory bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % inPurgatory signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % inPurgatory name with prefix 
    if(offset+uint32(2+11 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 11), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 11-1))) = [namePrefixBytes, uint8('inPurgatory')];
    offset = offset + uint32(numel(namePrefixBytes) + 11);

    % inPurgatory units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % inPurgatory data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % inPurgatory dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.inPurgatory)), 'uint8');
    offset = offset + uint32(2*1);

    % inPurgatory data
    nBytes = uint32(1 * numel(bus.inPurgatory));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.inPurgatory(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized purgatoryTimeRemaining
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.purgatoryTimeRemaining) == 1, 'numel(bus.purgatoryTimeRemaining) must be 1');    % purgatoryTimeRemaining bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % purgatoryTimeRemaining signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(5);
    offset = offset + uint32(1);

    % purgatoryTimeRemaining name with prefix 
    if(offset+uint32(2+22 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 22), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 22-1))) = [namePrefixBytes, uint8('purgatoryTimeRemaining')];
    offset = offset + uint32(numel(namePrefixBytes) + 22);

    % purgatoryTimeRemaining units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % purgatoryTimeRemaining data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % purgatoryTimeRemaining dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.purgatoryTimeRemaining)), 'uint8');
    offset = offset + uint32(2*1);

    % purgatoryTimeRemaining data
    nBytes = uint32(4 * numel(bus.purgatoryTimeRemaining));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.purgatoryTimeRemaining(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized holdXCenter
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.holdXCenter) == 1, 'numel(bus.holdXCenter) must be 1');    % holdXCenter bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % holdXCenter signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % holdXCenter name with prefix 
    if(offset+uint32(2+11 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 11), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 11-1))) = [namePrefixBytes, uint8('holdXCenter')];
    offset = offset + uint32(numel(namePrefixBytes) + 11);

    % holdXCenter units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('mm');
    offset = offset + uint32(2);

    % holdXCenter data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % holdXCenter dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.holdXCenter)), 'uint8');
    offset = offset + uint32(2*1);

    % holdXCenter data
    nBytes = uint32(8 * numel(bus.holdXCenter));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.holdXCenter(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized holdYCenter
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.holdYCenter) == 1, 'numel(bus.holdYCenter) must be 1');    % holdYCenter bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % holdYCenter signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % holdYCenter name with prefix 
    if(offset+uint32(2+11 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 11), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 11-1))) = [namePrefixBytes, uint8('holdYCenter')];
    offset = offset + uint32(numel(namePrefixBytes) + 11);

    % holdYCenter units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('mm');
    offset = offset + uint32(2);

    % holdYCenter data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % holdYCenter dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.holdYCenter)), 'uint8');
    offset = offset + uint32(2*1);

    % holdYCenter data
    nBytes = uint32(8 * numel(bus.holdYCenter));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.holdYCenter(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized holdXTarget
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.holdXTarget) == 1, 'numel(bus.holdXTarget) must be 1');    % holdXTarget bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % holdXTarget signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % holdXTarget name with prefix 
    if(offset+uint32(2+11 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 11), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 11-1))) = [namePrefixBytes, uint8('holdXTarget')];
    offset = offset + uint32(numel(namePrefixBytes) + 11);

    % holdXTarget units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('mm');
    offset = offset + uint32(2);

    % holdXTarget data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % holdXTarget dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.holdXTarget)), 'uint8');
    offset = offset + uint32(2*1);

    % holdXTarget data
    nBytes = uint32(8 * numel(bus.holdXTarget));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.holdXTarget(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized holdYTarget
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.holdYTarget) == 1, 'numel(bus.holdYTarget) must be 1');    % holdYTarget bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % holdYTarget signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % holdYTarget name with prefix 
    if(offset+uint32(2+11 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 11), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 11-1))) = [namePrefixBytes, uint8('holdYTarget')];
    offset = offset + uint32(numel(namePrefixBytes) + 11);

    % holdYTarget units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('mm');
    offset = offset + uint32(2);

    % holdYTarget data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % holdYTarget dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.holdYTarget)), 'uint8');
    offset = offset + uint32(2*1);

    % holdYTarget data
    nBytes = uint32(8 * numel(bus.holdYTarget));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.holdYTarget(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized decodeSuccess
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.decodeSuccess) == 1, 'numel(bus.decodeSuccess) must be 1');    % decodeSuccess bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % decodeSuccess signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % decodeSuccess name with prefix 
    if(offset+uint32(2+13 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 13), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 13-1))) = [namePrefixBytes, uint8('decodeSuccess')];
    offset = offset + uint32(numel(namePrefixBytes) + 13);

    % decodeSuccess units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % decodeSuccess data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % decodeSuccess dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.decodeSuccess)), 'uint8');
    offset = offset + uint32(2*1);

    % decodeSuccess data
    nBytes = uint32(1 * numel(bus.decodeSuccess));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.decodeSuccess(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized isDecodeCondition
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.isDecodeCondition) == 1, 'numel(bus.isDecodeCondition) must be 1');    % isDecodeCondition bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % isDecodeCondition signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % isDecodeCondition name with prefix 
    if(offset+uint32(2+17 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 17), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 17-1))) = [namePrefixBytes, uint8('isDecodeCondition')];
    offset = offset + uint32(numel(namePrefixBytes) + 17);

    % isDecodeCondition units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % isDecodeCondition data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % isDecodeCondition dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.isDecodeCondition)), 'uint8');
    offset = offset + uint32(2*1);

    % isDecodeCondition data
    nBytes = uint32(1 * numel(bus.isDecodeCondition));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.isDecodeCondition(:));
    end
    offset = offset + nBytes; %#ok<NASGU>

    valid = uint8(1);
end