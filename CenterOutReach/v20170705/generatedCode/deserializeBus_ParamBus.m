function [bus, valid, offset] = deserializeBus_ParamBus(input, offset, valid, namePrefix)
%#codegen
% DO NOT EDIT: Auto-generated by 
%   BusSerialize.writeDeserializeBusCode('ParamBus')

    in = typecast(input, 'uint8');
    if nargin < 2
         offset = uint32(1);
    end
    if nargin < 3
         valid = uint8(1);
    end
    if nargin < 4
        namePrefix = uint8('');
    end
    offset = uint32(offset);

    bus = initializeBus_ParamBus();
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field timeImagingStartBeforeTargetOnset
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(43 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_timeImagingStartBeforeTargetOnset = uint8([2, 4, typecast(uint16(numel(namePrefix) + 33), 'uint8'), namePrefix, 'timeImagingStartBeforeTargetOnset', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(43+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_timeImagingStartBeforeTargetOnset(headerOffset));
    end
    offset = offset + uint32(43 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.timeImagingStartBeforeTargetOnset = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.timeImagingStartBeforeTargetOnset = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.timeImagingStartBeforeTargetOnset = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.timeImagingStartBeforeTargetOnset(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field timeCenterAcquire
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(27 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_timeCenterAcquire = uint8([2, 4, typecast(uint16(numel(namePrefix) + 17), 'uint8'), namePrefix, 'timeCenterAcquire', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(27+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_timeCenterAcquire(headerOffset));
    end
    offset = offset + uint32(27 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.timeCenterAcquire = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.timeCenterAcquire = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.timeCenterAcquire = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.timeCenterAcquire(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field timeCenterSettle
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(26 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_timeCenterSettle = uint8([2, 4, typecast(uint16(numel(namePrefix) + 16), 'uint8'), namePrefix, 'timeCenterSettle', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(26+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_timeCenterSettle(headerOffset));
    end
    offset = offset + uint32(26 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.timeCenterSettle = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.timeCenterSettle = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.timeCenterSettle = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.timeCenterSettle(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field timeCenterHold
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(24 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_timeCenterHold = uint8([2, 4, typecast(uint16(numel(namePrefix) + 14), 'uint8'), namePrefix, 'timeCenterHold', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(24+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_timeCenterHold(headerOffset));
    end
    offset = offset + uint32(24 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.timeCenterHold = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.timeCenterHold = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.timeCenterHold = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.timeCenterHold(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field rtMin
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(15 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_rtMin = uint8([2, 4, typecast(uint16(numel(namePrefix) + 5), 'uint8'), namePrefix, 'rtMin', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(15+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_rtMin(headerOffset));
    end
    offset = offset + uint32(15 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.rtMin = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.rtMin = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.rtMin = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.rtMin(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field rtMax
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(15 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_rtMax = uint8([2, 4, typecast(uint16(numel(namePrefix) + 5), 'uint8'), namePrefix, 'rtMax', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(15+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_rtMax(headerOffset));
    end
    offset = offset + uint32(15 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.rtMax = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.rtMax = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.rtMax = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.rtMax(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field timeTargetAcquire
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(27 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_timeTargetAcquire = uint8([2, 4, typecast(uint16(numel(namePrefix) + 17), 'uint8'), namePrefix, 'timeTargetAcquire', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(27+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_timeTargetAcquire(headerOffset));
    end
    offset = offset + uint32(27 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.timeTargetAcquire = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.timeTargetAcquire = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.timeTargetAcquire = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.timeTargetAcquire(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field timeTargetSettle
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(26 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_timeTargetSettle = uint8([2, 4, typecast(uint16(numel(namePrefix) + 16), 'uint8'), namePrefix, 'timeTargetSettle', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(26+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_timeTargetSettle(headerOffset));
    end
    offset = offset + uint32(26 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.timeTargetSettle = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.timeTargetSettle = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.timeTargetSettle = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.timeTargetSettle(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field timeTargetHold
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(24 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_timeTargetHold = uint8([2, 4, typecast(uint16(numel(namePrefix) + 14), 'uint8'), namePrefix, 'timeTargetHold', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(24+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_timeTargetHold(headerOffset));
    end
    offset = offset + uint32(24 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.timeTargetHold = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.timeTargetHold = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.timeTargetHold = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.timeTargetHold(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field timeJuice
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(19 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_timeJuice = uint8([2, 4, typecast(uint16(numel(namePrefix) + 9), 'uint8'), namePrefix, 'timeJuice', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(19+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_timeJuice(headerOffset));
    end
    offset = offset + uint32(19 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.timeJuice = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.timeJuice = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.timeJuice = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.timeJuice(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field timeJuiceCenter
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(25 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_timeJuiceCenter = uint8([2, 4, typecast(uint16(numel(namePrefix) + 15), 'uint8'), namePrefix, 'timeJuiceCenter', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(25+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_timeJuiceCenter(headerOffset));
    end
    offset = offset + uint32(25 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.timeJuiceCenter = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.timeJuiceCenter = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.timeJuiceCenter = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.timeJuiceCenter(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field timeJuiceDecodeSuccess
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(32 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_timeJuiceDecodeSuccess = uint8([2, 4, typecast(uint16(numel(namePrefix) + 22), 'uint8'), namePrefix, 'timeJuiceDecodeSuccess', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(32+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_timeJuiceDecodeSuccess(headerOffset));
    end
    offset = offset + uint32(32 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.timeJuiceDecodeSuccess = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.timeJuiceDecodeSuccess = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.timeJuiceDecodeSuccess = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.timeJuiceDecodeSuccess(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field timeRewardFeedback
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(28 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_timeRewardFeedback = uint8([2, 4, typecast(uint16(numel(namePrefix) + 18), 'uint8'), namePrefix, 'timeRewardFeedback', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(28+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_timeRewardFeedback(headerOffset));
    end
    offset = offset + uint32(28 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.timeRewardFeedback = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.timeRewardFeedback = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.timeRewardFeedback = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.timeRewardFeedback(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field timeFailureFeedback
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(29 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_timeFailureFeedback = uint8([2, 4, typecast(uint16(numel(namePrefix) + 19), 'uint8'), namePrefix, 'timeFailureFeedback', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(29+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_timeFailureFeedback(headerOffset));
    end
    offset = offset + uint32(29 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.timeFailureFeedback = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.timeFailureFeedback = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.timeFailureFeedback = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.timeFailureFeedback(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field itiSuccess
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(20 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_itiSuccess = uint8([2, 4, typecast(uint16(numel(namePrefix) + 10), 'uint8'), namePrefix, 'itiSuccess', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(20+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_itiSuccess(headerOffset));
    end
    offset = offset + uint32(20 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.itiSuccess = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.itiSuccess = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.itiSuccess = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.itiSuccess(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field itiFailure
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(20 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_itiFailure = uint8([2, 4, typecast(uint16(numel(namePrefix) + 10), 'uint8'), namePrefix, 'itiFailure', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(20+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_itiFailure(headerOffset));
    end
    offset = offset + uint32(20 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.itiFailure = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.itiFailure = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.itiFailure = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.itiFailure(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field repeatUntilSuccess
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(26 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_repeatUntilSuccess = uint8([2, 4, typecast(uint16(numel(namePrefix) + 18), 'uint8'), namePrefix, 'repeatUntilSuccess', typecast(uint16(0), 'uint8'), '', 3, 1])';
    for headerOffset = 1:uint32(26+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_repeatUntilSuccess(headerOffset));
    end
    offset = offset + uint32(26 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.repeatUntilSuccess = zeros([1 1], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*1 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.repeatUntilSuccess = zeros([1 1], 'uint8');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.repeatUntilSuccess = zeros([1 1], 'uint8');
            if elements > uint32(0)
                bus.repeatUntilSuccess(1:elements) = typecast(in(offset:offset+uint32(elements*1 - 1))', 'uint8')';
                offset = offset + uint32(elements*1);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field delayVibrateSigma
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(27 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_delayVibrateSigma = uint8([2, 4, typecast(uint16(numel(namePrefix) + 17), 'uint8'), namePrefix, 'delayVibrateSigma', typecast(uint16(2), 'uint8'), 'mm', 0, 1])';
    for headerOffset = 1:uint32(27+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_delayVibrateSigma(headerOffset));
    end
    offset = offset + uint32(27 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.delayVibrateSigma = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.delayVibrateSigma = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.delayVibrateSigma = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.delayVibrateSigma(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field purgatoryTime
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(23 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_purgatoryTime = uint8([2, 4, typecast(uint16(numel(namePrefix) + 13), 'uint8'), namePrefix, 'purgatoryTime', typecast(uint16(2), 'uint8'), 'ms', 7, 1])';
    for headerOffset = 1:uint32(23+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_purgatoryTime(headerOffset));
    end
    offset = offset + uint32(23 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.purgatoryTime = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.purgatoryTime = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.purgatoryTime = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.purgatoryTime(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field purgatoryConsecutiveNoStarts
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(36 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_purgatoryConsecutiveNoStarts = uint8([2, 4, typecast(uint16(numel(namePrefix) + 28), 'uint8'), namePrefix, 'purgatoryConsecutiveNoStarts', typecast(uint16(0), 'uint8'), '', 5, 1])';
    for headerOffset = 1:uint32(36+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_purgatoryConsecutiveNoStarts(headerOffset));
    end
    offset = offset + uint32(36 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.purgatoryConsecutiveNoStarts = zeros([1 1], 'uint16');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*2 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.purgatoryConsecutiveNoStarts = zeros([1 1], 'uint16');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.purgatoryConsecutiveNoStarts = zeros([1 1], 'uint16');
            if elements > uint32(0)
                bus.purgatoryConsecutiveNoStarts(1:elements) = typecast(in(offset:offset+uint32(elements*2 - 1))', 'uint16')';
                offset = offset + uint32(elements*2);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field centerSize
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(20 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_centerSize = uint8([2, 4, typecast(uint16(numel(namePrefix) + 10), 'uint8'), namePrefix, 'centerSize', typecast(uint16(2), 'uint8'), 'mm', 0, 1])';
    for headerOffset = 1:uint32(20+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_centerSize(headerOffset));
    end
    offset = offset + uint32(20 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.centerSize = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.centerSize = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.centerSize = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.centerSize(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field centerHoldWindowSize
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(30 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_centerHoldWindowSize = uint8([2, 4, typecast(uint16(numel(namePrefix) + 20), 'uint8'), namePrefix, 'centerHoldWindowSize', typecast(uint16(2), 'uint8'), 'mm', 0, 1])';
    for headerOffset = 1:uint32(30+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_centerHoldWindowSize(headerOffset));
    end
    offset = offset + uint32(30 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.centerHoldWindowSize = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.centerHoldWindowSize = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.centerHoldWindowSize = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.centerHoldWindowSize(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field targetHoldWindowSize
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(30 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_targetHoldWindowSize = uint8([2, 4, typecast(uint16(numel(namePrefix) + 20), 'uint8'), namePrefix, 'targetHoldWindowSize', typecast(uint16(2), 'uint8'), 'mm', 0, 1])';
    for headerOffset = 1:uint32(30+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_targetHoldWindowSize(headerOffset));
    end
    offset = offset + uint32(30 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.targetHoldWindowSize = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.targetHoldWindowSize = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.targetHoldWindowSize = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.targetHoldWindowSize(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field acceptanceWindowPadding
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(33 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_acceptanceWindowPadding = uint8([2, 4, typecast(uint16(numel(namePrefix) + 23), 'uint8'), namePrefix, 'acceptanceWindowPadding', typecast(uint16(2), 'uint8'), 'mm', 0, 1])';
    for headerOffset = 1:uint32(33+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_acceptanceWindowPadding(headerOffset));
    end
    offset = offset + uint32(33 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.acceptanceWindowPadding = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.acceptanceWindowPadding = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.acceptanceWindowPadding = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.acceptanceWindowPadding(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field distanceTowardsTargetThresh
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(35 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_distanceTowardsTargetThresh = uint8([2, 4, typecast(uint16(numel(namePrefix) + 27), 'uint8'), namePrefix, 'distanceTowardsTargetThresh', typecast(uint16(0), 'uint8'), '', 0, 1])';
    for headerOffset = 1:uint32(35+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_distanceTowardsTargetThresh(headerOffset));
    end
    offset = offset + uint32(35 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.distanceTowardsTargetThresh = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.distanceTowardsTargetThresh = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.distanceTowardsTargetThresh = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.distanceTowardsTargetThresh(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field velocityTowardsTargetThresh
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(35 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_velocityTowardsTargetThresh = uint8([2, 4, typecast(uint16(numel(namePrefix) + 27), 'uint8'), namePrefix, 'velocityTowardsTargetThresh', typecast(uint16(0), 'uint8'), '', 0, 1])';
    for headerOffset = 1:uint32(35+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_velocityTowardsTargetThresh(headerOffset));
    end
    offset = offset + uint32(35 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.velocityTowardsTargetThresh = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.velocityTowardsTargetThresh = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.velocityTowardsTargetThresh = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.velocityTowardsTargetThresh(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field threshAcceleration
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(34 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_threshAcceleration = uint8([2, 4, typecast(uint16(numel(namePrefix) + 18), 'uint8'), namePrefix, 'threshAcceleration', typecast(uint16(8), 'uint8'), 'mm/sec^2', 0, 1])';
    for headerOffset = 1:uint32(34+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_threshAcceleration(headerOffset));
    end
    offset = offset + uint32(34 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.threshAcceleration = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.threshAcceleration = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.threshAcceleration = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.threshAcceleration(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field decelerationThreshRatio
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(31 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_decelerationThreshRatio = uint8([2, 4, typecast(uint16(numel(namePrefix) + 23), 'uint8'), namePrefix, 'decelerationThreshRatio', typecast(uint16(0), 'uint8'), '', 0, 1])';
    for headerOffset = 1:uint32(31+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_decelerationThreshRatio(headerOffset));
    end
    offset = offset + uint32(31 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.decelerationThreshRatio = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.decelerationThreshRatio = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.decelerationThreshRatio = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.decelerationThreshRatio(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field reaccelerationThreshDelta
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(41 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_reaccelerationThreshDelta = uint8([2, 4, typecast(uint16(numel(namePrefix) + 25), 'uint8'), namePrefix, 'reaccelerationThreshDelta', typecast(uint16(8), 'uint8'), 'mm/sec^2', 0, 1])';
    for headerOffset = 1:uint32(41+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_reaccelerationThreshDelta(headerOffset));
    end
    offset = offset + uint32(41 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.reaccelerationThreshDelta = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.reaccelerationThreshDelta = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.reaccelerationThreshDelta = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.reaccelerationThreshDelta(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field minPeakVelocityTowardsTarget
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(42 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_minPeakVelocityTowardsTarget = uint8([2, 4, typecast(uint16(numel(namePrefix) + 28), 'uint8'), namePrefix, 'minPeakVelocityTowardsTarget', typecast(uint16(6), 'uint8'), 'mm/sec', 0, 1])';
    for headerOffset = 1:uint32(42+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_minPeakVelocityTowardsTarget(headerOffset));
    end
    offset = offset + uint32(42 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.minPeakVelocityTowardsTarget = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.minPeakVelocityTowardsTarget = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.minPeakVelocityTowardsTarget = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.minPeakVelocityTowardsTarget(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field targetHoldJuiceSize
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(29 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_targetHoldJuiceSize = uint8([2, 4, typecast(uint16(numel(namePrefix) + 19), 'uint8'), namePrefix, 'targetHoldJuiceSize', typecast(uint16(2), 'uint8'), 'ms', 0, 1])';
    for headerOffset = 1:uint32(29+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_targetHoldJuiceSize(headerOffset));
    end
    offset = offset + uint32(29 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.targetHoldJuiceSize = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.targetHoldJuiceSize = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.targetHoldJuiceSize = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.targetHoldJuiceSize(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field targetHoldJuiceInterval
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(33 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_targetHoldJuiceInterval = uint8([2, 4, typecast(uint16(numel(namePrefix) + 23), 'uint8'), namePrefix, 'targetHoldJuiceInterval', typecast(uint16(2), 'uint8'), 'ms', 0, 1])';
    for headerOffset = 1:uint32(33+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_targetHoldJuiceInterval(headerOffset));
    end
    offset = offset + uint32(33 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.targetHoldJuiceInterval = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.targetHoldJuiceInterval = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.targetHoldJuiceInterval = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.targetHoldJuiceInterval(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field allowHandNotSeen
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(24 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_allowHandNotSeen = uint8([2, 4, typecast(uint16(numel(namePrefix) + 16), 'uint8'), namePrefix, 'allowHandNotSeen', typecast(uint16(0), 'uint8'), '', 3, 1])';
    for headerOffset = 1:uint32(24+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_allowHandNotSeen(headerOffset));
    end
    offset = offset + uint32(24 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.allowHandNotSeen = zeros([1 1], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*1 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.allowHandNotSeen = zeros([1 1], 'uint8');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.allowHandNotSeen = zeros([1 1], 'uint8');
            if elements > uint32(0)
                bus.allowHandNotSeen(1:elements) = typecast(in(offset:offset+uint32(elements*1 - 1))', 'uint8')';
                offset = offset + uint32(elements*1);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field allowReacquireCenter
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(28 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_allowReacquireCenter = uint8([2, 4, typecast(uint16(numel(namePrefix) + 20), 'uint8'), namePrefix, 'allowReacquireCenter', typecast(uint16(0), 'uint8'), '', 3, 1])';
    for headerOffset = 1:uint32(28+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_allowReacquireCenter(headerOffset));
    end
    offset = offset + uint32(28 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.allowReacquireCenter = zeros([1 1], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*1 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.allowReacquireCenter = zeros([1 1], 'uint8');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.allowReacquireCenter = zeros([1 1], 'uint8');
            if elements > uint32(0)
                bus.allowReacquireCenter(1:elements) = typecast(in(offset:offset+uint32(elements*1 - 1))', 'uint8')';
                offset = offset + uint32(elements*1);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field allowReacquireTarget
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(28 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_allowReacquireTarget = uint8([2, 4, typecast(uint16(numel(namePrefix) + 20), 'uint8'), namePrefix, 'allowReacquireTarget', typecast(uint16(0), 'uint8'), '', 3, 1])';
    for headerOffset = 1:uint32(28+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_allowReacquireTarget(headerOffset));
    end
    offset = offset + uint32(28 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.allowReacquireTarget = zeros([1 1], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*1 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.allowReacquireTarget = zeros([1 1], 'uint8');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.allowReacquireTarget = zeros([1 1], 'uint8');
            if elements > uint32(0)
                bus.allowReacquireTarget(1:elements) = typecast(in(offset:offset+uint32(elements*1 - 1))', 'uint8')';
                offset = offset + uint32(elements*1);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field frameSkipTime
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(23 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_frameSkipTime = uint8([2, 4, typecast(uint16(numel(namePrefix) + 13), 'uint8'), namePrefix, 'frameSkipTime', typecast(uint16(2), 'uint8'), 'ms', 0, 1])';
    for headerOffset = 1:uint32(23+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_frameSkipTime(headerOffset));
    end
    offset = offset + uint32(23 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.frameSkipTime = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.frameSkipTime = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.frameSkipTime = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.frameSkipTime(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field frameIntegrationTime
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(30 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_frameIntegrationTime = uint8([2, 4, typecast(uint16(numel(namePrefix) + 20), 'uint8'), namePrefix, 'frameIntegrationTime', typecast(uint16(2), 'uint8'), 'ms', 0, 1])';
    for headerOffset = 1:uint32(30+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_frameIntegrationTime(headerOffset));
    end
    offset = offset + uint32(30 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.frameIntegrationTime = zeros([1 1], 'double');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*8 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.frameIntegrationTime = zeros([1 1], 'double');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.frameIntegrationTime = zeros([1 1], 'double');
            if elements > uint32(0)
                bus.frameIntegrationTime(1:elements) = typecast(in(offset:offset+uint32(elements*8 - 1))', 'double')';
                offset = offset + uint32(elements*8);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field imageDecoderTraining
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(28 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_imageDecoderTraining = uint8([2, 4, typecast(uint16(numel(namePrefix) + 20), 'uint8'), namePrefix, 'imageDecoderTraining', typecast(uint16(0), 'uint8'), '', 3, 1])';
    for headerOffset = 1:uint32(28+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_imageDecoderTraining(headerOffset));
    end
    offset = offset + uint32(28 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.imageDecoderTraining = zeros([1 1], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*1 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.imageDecoderTraining = zeros([1 1], 'uint8');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.imageDecoderTraining = zeros([1 1], 'uint8');
            if elements > uint32(0)
                bus.imageDecoderTraining(1:elements) = typecast(in(offset:offset+uint32(elements*1 - 1))', 'uint8')';
                offset = offset + uint32(elements*1);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field resetImageDecoder
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(25 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_resetImageDecoder = uint8([2, 5, typecast(uint16(numel(namePrefix) + 17), 'uint8'), namePrefix, 'resetImageDecoder', typecast(uint16(0), 'uint8'), '', 3, 1])';
    for headerOffset = 1:uint32(25+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_resetImageDecoder(headerOffset));
    end
    offset = offset + uint32(25 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.resetImageDecoder = zeros([1 1], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*1 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.resetImageDecoder = zeros([1 1], 'uint8');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.resetImageDecoder = zeros([1 1], 'uint8');
            if elements > uint32(0)
                bus.resetImageDecoder(1:elements) = typecast(in(offset:offset+uint32(elements*1 - 1))', 'uint8')';
                offset = offset + uint32(elements*1);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field imageDecoderDebugDisplayMode
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(36 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_imageDecoderDebugDisplayMode = uint8([2, 4, typecast(uint16(numel(namePrefix) + 28), 'uint8'), namePrefix, 'imageDecoderDebugDisplayMode', typecast(uint16(0), 'uint8'), '', 3, 1])';
    for headerOffset = 1:uint32(36+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_imageDecoderDebugDisplayMode(headerOffset));
    end
    offset = offset + uint32(36 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.imageDecoderDebugDisplayMode = zeros([1 1], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*1 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.imageDecoderDebugDisplayMode = zeros([1 1], 'uint8');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.imageDecoderDebugDisplayMode = zeros([1 1], 'uint8');
            if elements > uint32(0)
                bus.imageDecoderDebugDisplayMode(1:elements) = typecast(in(offset:offset+uint32(elements*1 - 1))', 'uint8')';
                offset = offset + uint32(elements*1);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field conditionsToDecode
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(30 + numel(namePrefix) - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_conditionsToDecode = uint8([2, 4, typecast(uint16(numel(namePrefix) + 18), 'uint8'), namePrefix, 'conditionsToDecode', typecast(uint16(4), 'uint8'), 'bool', 9, 1])';
    for headerOffset = 1:uint32(30+numel(namePrefix)-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_conditionsToDecode(headerOffset));
    end
    offset = offset + uint32(30 + numel(namePrefix));

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.conditionsToDecode = zeros([4 1], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(4), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*1 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.conditionsToDecode = zeros([4 1], 'uint8');
        else
            % read and typecast data
            assert(elements <= uint32(4));
            bus.conditionsToDecode = zeros([4 1], 'uint8');
            if elements > uint32(0)
                bus.conditionsToDecode(1:elements) = typecast(in(offset:offset+uint32(elements*1 - 1))', 'uint8')';
                offset = offset + uint32(elements*1);
            end
        end
    end


end