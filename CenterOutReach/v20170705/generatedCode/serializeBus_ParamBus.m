function [out, valid] = serializeBus_ParamBus(bus, namePrefix)
%#codegen
% DO NOT EDIT: Auto-generated by 
%   BusSerialize.writeSerializeBusCode('ParamBus')

    if nargin < 2, namePrefix = uint8(''); end
    namePrefixBytes = uint8(namePrefix(:))';
    valid = uint8(0);
    outSize = getSerializedBusLength_ParamBus(bus, namePrefix);
    assert(outSize <= 1440 + 41*numel(namePrefix));
    out = zeros(outSize, 1, 'uint8');
    offset = uint32(1);

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized timeImagingStartBeforeTargetOnset
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.timeImagingStartBeforeTargetOnset) == 1, 'numel(bus.timeImagingStartBeforeTargetOnset) must be 1');    % timeImagingStartBeforeTargetOnset bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % timeImagingStartBeforeTargetOnset signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % timeImagingStartBeforeTargetOnset name with prefix 
    if(offset+uint32(2+33 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 33), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 33-1))) = [namePrefixBytes, uint8('timeImagingStartBeforeTargetOnset')];
    offset = offset + uint32(numel(namePrefixBytes) + 33);

    % timeImagingStartBeforeTargetOnset units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % timeImagingStartBeforeTargetOnset data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % timeImagingStartBeforeTargetOnset dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.timeImagingStartBeforeTargetOnset)), 'uint8');
    offset = offset + uint32(2*1);

    % timeImagingStartBeforeTargetOnset data
    nBytes = uint32(4 * numel(bus.timeImagingStartBeforeTargetOnset));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.timeImagingStartBeforeTargetOnset(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized timeCenterAcquire
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.timeCenterAcquire) == 1, 'numel(bus.timeCenterAcquire) must be 1');    % timeCenterAcquire bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % timeCenterAcquire signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % timeCenterAcquire name with prefix 
    if(offset+uint32(2+17 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 17), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 17-1))) = [namePrefixBytes, uint8('timeCenterAcquire')];
    offset = offset + uint32(numel(namePrefixBytes) + 17);

    % timeCenterAcquire units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % timeCenterAcquire data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % timeCenterAcquire dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.timeCenterAcquire)), 'uint8');
    offset = offset + uint32(2*1);

    % timeCenterAcquire data
    nBytes = uint32(4 * numel(bus.timeCenterAcquire));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.timeCenterAcquire(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized timeCenterSettle
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.timeCenterSettle) == 1, 'numel(bus.timeCenterSettle) must be 1');    % timeCenterSettle bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % timeCenterSettle signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % timeCenterSettle name with prefix 
    if(offset+uint32(2+16 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 16), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 16-1))) = [namePrefixBytes, uint8('timeCenterSettle')];
    offset = offset + uint32(numel(namePrefixBytes) + 16);

    % timeCenterSettle units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % timeCenterSettle data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % timeCenterSettle dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.timeCenterSettle)), 'uint8');
    offset = offset + uint32(2*1);

    % timeCenterSettle data
    nBytes = uint32(4 * numel(bus.timeCenterSettle));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.timeCenterSettle(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized timeCenterHold
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.timeCenterHold) == 1, 'numel(bus.timeCenterHold) must be 1');    % timeCenterHold bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % timeCenterHold signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % timeCenterHold name with prefix 
    if(offset+uint32(2+14 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 14), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 14-1))) = [namePrefixBytes, uint8('timeCenterHold')];
    offset = offset + uint32(numel(namePrefixBytes) + 14);

    % timeCenterHold units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % timeCenterHold data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % timeCenterHold dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.timeCenterHold)), 'uint8');
    offset = offset + uint32(2*1);

    % timeCenterHold data
    nBytes = uint32(4 * numel(bus.timeCenterHold));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.timeCenterHold(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized rtMin
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.rtMin) == 1, 'numel(bus.rtMin) must be 1');    % rtMin bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % rtMin signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % rtMin name with prefix 
    if(offset+uint32(2+5 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 5), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 5-1))) = [namePrefixBytes, uint8('rtMin')];
    offset = offset + uint32(numel(namePrefixBytes) + 5);

    % rtMin units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % rtMin data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % rtMin dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.rtMin)), 'uint8');
    offset = offset + uint32(2*1);

    % rtMin data
    nBytes = uint32(4 * numel(bus.rtMin));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.rtMin(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized rtMax
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.rtMax) == 1, 'numel(bus.rtMax) must be 1');    % rtMax bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % rtMax signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % rtMax name with prefix 
    if(offset+uint32(2+5 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 5), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 5-1))) = [namePrefixBytes, uint8('rtMax')];
    offset = offset + uint32(numel(namePrefixBytes) + 5);

    % rtMax units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % rtMax data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % rtMax dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.rtMax)), 'uint8');
    offset = offset + uint32(2*1);

    % rtMax data
    nBytes = uint32(4 * numel(bus.rtMax));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.rtMax(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized timeTargetAcquire
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.timeTargetAcquire) == 1, 'numel(bus.timeTargetAcquire) must be 1');    % timeTargetAcquire bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % timeTargetAcquire signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % timeTargetAcquire name with prefix 
    if(offset+uint32(2+17 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 17), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 17-1))) = [namePrefixBytes, uint8('timeTargetAcquire')];
    offset = offset + uint32(numel(namePrefixBytes) + 17);

    % timeTargetAcquire units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % timeTargetAcquire data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % timeTargetAcquire dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.timeTargetAcquire)), 'uint8');
    offset = offset + uint32(2*1);

    % timeTargetAcquire data
    nBytes = uint32(4 * numel(bus.timeTargetAcquire));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.timeTargetAcquire(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized timeTargetSettle
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.timeTargetSettle) == 1, 'numel(bus.timeTargetSettle) must be 1');    % timeTargetSettle bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % timeTargetSettle signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % timeTargetSettle name with prefix 
    if(offset+uint32(2+16 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 16), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 16-1))) = [namePrefixBytes, uint8('timeTargetSettle')];
    offset = offset + uint32(numel(namePrefixBytes) + 16);

    % timeTargetSettle units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % timeTargetSettle data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % timeTargetSettle dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.timeTargetSettle)), 'uint8');
    offset = offset + uint32(2*1);

    % timeTargetSettle data
    nBytes = uint32(4 * numel(bus.timeTargetSettle));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.timeTargetSettle(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized timeTargetHold
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.timeTargetHold) == 1, 'numel(bus.timeTargetHold) must be 1');    % timeTargetHold bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % timeTargetHold signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % timeTargetHold name with prefix 
    if(offset+uint32(2+14 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 14), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 14-1))) = [namePrefixBytes, uint8('timeTargetHold')];
    offset = offset + uint32(numel(namePrefixBytes) + 14);

    % timeTargetHold units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % timeTargetHold data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % timeTargetHold dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.timeTargetHold)), 'uint8');
    offset = offset + uint32(2*1);

    % timeTargetHold data
    nBytes = uint32(4 * numel(bus.timeTargetHold));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.timeTargetHold(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized timeJuice
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.timeJuice) == 1, 'numel(bus.timeJuice) must be 1');    % timeJuice bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % timeJuice signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % timeJuice name with prefix 
    if(offset+uint32(2+9 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 9), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 9-1))) = [namePrefixBytes, uint8('timeJuice')];
    offset = offset + uint32(numel(namePrefixBytes) + 9);

    % timeJuice units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % timeJuice data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % timeJuice dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.timeJuice)), 'uint8');
    offset = offset + uint32(2*1);

    % timeJuice data
    nBytes = uint32(4 * numel(bus.timeJuice));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.timeJuice(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized timeJuiceCenter
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.timeJuiceCenter) == 1, 'numel(bus.timeJuiceCenter) must be 1');    % timeJuiceCenter bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % timeJuiceCenter signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % timeJuiceCenter name with prefix 
    if(offset+uint32(2+15 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 15), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 15-1))) = [namePrefixBytes, uint8('timeJuiceCenter')];
    offset = offset + uint32(numel(namePrefixBytes) + 15);

    % timeJuiceCenter units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % timeJuiceCenter data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % timeJuiceCenter dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.timeJuiceCenter)), 'uint8');
    offset = offset + uint32(2*1);

    % timeJuiceCenter data
    nBytes = uint32(4 * numel(bus.timeJuiceCenter));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.timeJuiceCenter(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized timeJuiceDecodeSuccess
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.timeJuiceDecodeSuccess) == 1, 'numel(bus.timeJuiceDecodeSuccess) must be 1');    % timeJuiceDecodeSuccess bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % timeJuiceDecodeSuccess signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % timeJuiceDecodeSuccess name with prefix 
    if(offset+uint32(2+22 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 22), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 22-1))) = [namePrefixBytes, uint8('timeJuiceDecodeSuccess')];
    offset = offset + uint32(numel(namePrefixBytes) + 22);

    % timeJuiceDecodeSuccess units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % timeJuiceDecodeSuccess data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % timeJuiceDecodeSuccess dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.timeJuiceDecodeSuccess)), 'uint8');
    offset = offset + uint32(2*1);

    % timeJuiceDecodeSuccess data
    nBytes = uint32(4 * numel(bus.timeJuiceDecodeSuccess));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.timeJuiceDecodeSuccess(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized timeRewardFeedback
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.timeRewardFeedback) == 1, 'numel(bus.timeRewardFeedback) must be 1');    % timeRewardFeedback bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % timeRewardFeedback signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % timeRewardFeedback name with prefix 
    if(offset+uint32(2+18 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 18), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 18-1))) = [namePrefixBytes, uint8('timeRewardFeedback')];
    offset = offset + uint32(numel(namePrefixBytes) + 18);

    % timeRewardFeedback units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % timeRewardFeedback data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % timeRewardFeedback dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.timeRewardFeedback)), 'uint8');
    offset = offset + uint32(2*1);

    % timeRewardFeedback data
    nBytes = uint32(4 * numel(bus.timeRewardFeedback));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.timeRewardFeedback(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized timeFailureFeedback
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.timeFailureFeedback) == 1, 'numel(bus.timeFailureFeedback) must be 1');    % timeFailureFeedback bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % timeFailureFeedback signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % timeFailureFeedback name with prefix 
    if(offset+uint32(2+19 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 19), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 19-1))) = [namePrefixBytes, uint8('timeFailureFeedback')];
    offset = offset + uint32(numel(namePrefixBytes) + 19);

    % timeFailureFeedback units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % timeFailureFeedback data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % timeFailureFeedback dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.timeFailureFeedback)), 'uint8');
    offset = offset + uint32(2*1);

    % timeFailureFeedback data
    nBytes = uint32(4 * numel(bus.timeFailureFeedback));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.timeFailureFeedback(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized itiSuccess
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.itiSuccess) == 1, 'numel(bus.itiSuccess) must be 1');    % itiSuccess bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % itiSuccess signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % itiSuccess name with prefix 
    if(offset+uint32(2+10 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 10), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 10-1))) = [namePrefixBytes, uint8('itiSuccess')];
    offset = offset + uint32(numel(namePrefixBytes) + 10);

    % itiSuccess units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % itiSuccess data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % itiSuccess dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.itiSuccess)), 'uint8');
    offset = offset + uint32(2*1);

    % itiSuccess data
    nBytes = uint32(4 * numel(bus.itiSuccess));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.itiSuccess(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized itiFailure
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.itiFailure) == 1, 'numel(bus.itiFailure) must be 1');    % itiFailure bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % itiFailure signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % itiFailure name with prefix 
    if(offset+uint32(2+10 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 10), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 10-1))) = [namePrefixBytes, uint8('itiFailure')];
    offset = offset + uint32(numel(namePrefixBytes) + 10);

    % itiFailure units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % itiFailure data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % itiFailure dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.itiFailure)), 'uint8');
    offset = offset + uint32(2*1);

    % itiFailure data
    nBytes = uint32(4 * numel(bus.itiFailure));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.itiFailure(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized repeatUntilSuccess
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.repeatUntilSuccess) == 1, 'numel(bus.repeatUntilSuccess) must be 1');    % repeatUntilSuccess bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % repeatUntilSuccess signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % repeatUntilSuccess name with prefix 
    if(offset+uint32(2+18 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 18), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 18-1))) = [namePrefixBytes, uint8('repeatUntilSuccess')];
    offset = offset + uint32(numel(namePrefixBytes) + 18);

    % repeatUntilSuccess units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % repeatUntilSuccess data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % repeatUntilSuccess dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.repeatUntilSuccess)), 'uint8');
    offset = offset + uint32(2*1);

    % repeatUntilSuccess data
    nBytes = uint32(1 * numel(bus.repeatUntilSuccess));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.repeatUntilSuccess(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized delayVibrateSigma
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.delayVibrateSigma) == 1, 'numel(bus.delayVibrateSigma) must be 1');    % delayVibrateSigma bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % delayVibrateSigma signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % delayVibrateSigma name with prefix 
    if(offset+uint32(2+17 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 17), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 17-1))) = [namePrefixBytes, uint8('delayVibrateSigma')];
    offset = offset + uint32(numel(namePrefixBytes) + 17);

    % delayVibrateSigma units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('mm');
    offset = offset + uint32(2);

    % delayVibrateSigma data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % delayVibrateSigma dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.delayVibrateSigma)), 'uint8');
    offset = offset + uint32(2*1);

    % delayVibrateSigma data
    nBytes = uint32(8 * numel(bus.delayVibrateSigma));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.delayVibrateSigma(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized purgatoryTime
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.purgatoryTime) == 1, 'numel(bus.purgatoryTime) must be 1');    % purgatoryTime bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % purgatoryTime signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % purgatoryTime name with prefix 
    if(offset+uint32(2+13 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 13), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 13-1))) = [namePrefixBytes, uint8('purgatoryTime')];
    offset = offset + uint32(numel(namePrefixBytes) + 13);

    % purgatoryTime units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % purgatoryTime data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(7); % data type is uint32
    offset = offset + uint32(1);

    % purgatoryTime dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.purgatoryTime)), 'uint8');
    offset = offset + uint32(2*1);

    % purgatoryTime data
    nBytes = uint32(4 * numel(bus.purgatoryTime));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint32(bus.purgatoryTime(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized purgatoryConsecutiveNoStarts
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.purgatoryConsecutiveNoStarts) == 1, 'numel(bus.purgatoryConsecutiveNoStarts) must be 1');    % purgatoryConsecutiveNoStarts bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % purgatoryConsecutiveNoStarts signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % purgatoryConsecutiveNoStarts name with prefix 
    if(offset+uint32(2+28 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 28), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 28-1))) = [namePrefixBytes, uint8('purgatoryConsecutiveNoStarts')];
    offset = offset + uint32(numel(namePrefixBytes) + 28);

    % purgatoryConsecutiveNoStarts units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % purgatoryConsecutiveNoStarts data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(5); % data type is uint16
    offset = offset + uint32(1);

    % purgatoryConsecutiveNoStarts dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.purgatoryConsecutiveNoStarts)), 'uint8');
    offset = offset + uint32(2*1);

    % purgatoryConsecutiveNoStarts data
    nBytes = uint32(2 * numel(bus.purgatoryConsecutiveNoStarts));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint16(bus.purgatoryConsecutiveNoStarts(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized centerSize
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.centerSize) == 1, 'numel(bus.centerSize) must be 1');    % centerSize bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % centerSize signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % centerSize name with prefix 
    if(offset+uint32(2+10 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 10), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 10-1))) = [namePrefixBytes, uint8('centerSize')];
    offset = offset + uint32(numel(namePrefixBytes) + 10);

    % centerSize units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('mm');
    offset = offset + uint32(2);

    % centerSize data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % centerSize dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.centerSize)), 'uint8');
    offset = offset + uint32(2*1);

    % centerSize data
    nBytes = uint32(8 * numel(bus.centerSize));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.centerSize(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized centerHoldWindowSize
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.centerHoldWindowSize) == 1, 'numel(bus.centerHoldWindowSize) must be 1');    % centerHoldWindowSize bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % centerHoldWindowSize signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % centerHoldWindowSize name with prefix 
    if(offset+uint32(2+20 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 20), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 20-1))) = [namePrefixBytes, uint8('centerHoldWindowSize')];
    offset = offset + uint32(numel(namePrefixBytes) + 20);

    % centerHoldWindowSize units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('mm');
    offset = offset + uint32(2);

    % centerHoldWindowSize data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % centerHoldWindowSize dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.centerHoldWindowSize)), 'uint8');
    offset = offset + uint32(2*1);

    % centerHoldWindowSize data
    nBytes = uint32(8 * numel(bus.centerHoldWindowSize));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.centerHoldWindowSize(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized targetHoldWindowSize
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.targetHoldWindowSize) == 1, 'numel(bus.targetHoldWindowSize) must be 1');    % targetHoldWindowSize bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % targetHoldWindowSize signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % targetHoldWindowSize name with prefix 
    if(offset+uint32(2+20 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 20), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 20-1))) = [namePrefixBytes, uint8('targetHoldWindowSize')];
    offset = offset + uint32(numel(namePrefixBytes) + 20);

    % targetHoldWindowSize units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('mm');
    offset = offset + uint32(2);

    % targetHoldWindowSize data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % targetHoldWindowSize dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.targetHoldWindowSize)), 'uint8');
    offset = offset + uint32(2*1);

    % targetHoldWindowSize data
    nBytes = uint32(8 * numel(bus.targetHoldWindowSize));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.targetHoldWindowSize(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized acceptanceWindowPadding
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.acceptanceWindowPadding) == 1, 'numel(bus.acceptanceWindowPadding) must be 1');    % acceptanceWindowPadding bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % acceptanceWindowPadding signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % acceptanceWindowPadding name with prefix 
    if(offset+uint32(2+23 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 23), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 23-1))) = [namePrefixBytes, uint8('acceptanceWindowPadding')];
    offset = offset + uint32(numel(namePrefixBytes) + 23);

    % acceptanceWindowPadding units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('mm');
    offset = offset + uint32(2);

    % acceptanceWindowPadding data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % acceptanceWindowPadding dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.acceptanceWindowPadding)), 'uint8');
    offset = offset + uint32(2*1);

    % acceptanceWindowPadding data
    nBytes = uint32(8 * numel(bus.acceptanceWindowPadding));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.acceptanceWindowPadding(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized distanceTowardsTargetThresh
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.distanceTowardsTargetThresh) == 1, 'numel(bus.distanceTowardsTargetThresh) must be 1');    % distanceTowardsTargetThresh bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % distanceTowardsTargetThresh signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % distanceTowardsTargetThresh name with prefix 
    if(offset+uint32(2+27 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 27), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 27-1))) = [namePrefixBytes, uint8('distanceTowardsTargetThresh')];
    offset = offset + uint32(numel(namePrefixBytes) + 27);

    % distanceTowardsTargetThresh units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % distanceTowardsTargetThresh data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % distanceTowardsTargetThresh dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.distanceTowardsTargetThresh)), 'uint8');
    offset = offset + uint32(2*1);

    % distanceTowardsTargetThresh data
    nBytes = uint32(8 * numel(bus.distanceTowardsTargetThresh));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.distanceTowardsTargetThresh(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized velocityTowardsTargetThresh
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.velocityTowardsTargetThresh) == 1, 'numel(bus.velocityTowardsTargetThresh) must be 1');    % velocityTowardsTargetThresh bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % velocityTowardsTargetThresh signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % velocityTowardsTargetThresh name with prefix 
    if(offset+uint32(2+27 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 27), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 27-1))) = [namePrefixBytes, uint8('velocityTowardsTargetThresh')];
    offset = offset + uint32(numel(namePrefixBytes) + 27);

    % velocityTowardsTargetThresh units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % velocityTowardsTargetThresh data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % velocityTowardsTargetThresh dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.velocityTowardsTargetThresh)), 'uint8');
    offset = offset + uint32(2*1);

    % velocityTowardsTargetThresh data
    nBytes = uint32(8 * numel(bus.velocityTowardsTargetThresh));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.velocityTowardsTargetThresh(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized threshAcceleration
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.threshAcceleration) == 1, 'numel(bus.threshAcceleration) must be 1');    % threshAcceleration bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % threshAcceleration signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % threshAcceleration name with prefix 
    if(offset+uint32(2+18 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 18), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 18-1))) = [namePrefixBytes, uint8('threshAcceleration')];
    offset = offset + uint32(numel(namePrefixBytes) + 18);

    % threshAcceleration units
    if(offset+uint32(2+8 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(8), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(8-1))) = uint8('mm/sec^2');
    offset = offset + uint32(8);

    % threshAcceleration data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % threshAcceleration dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.threshAcceleration)), 'uint8');
    offset = offset + uint32(2*1);

    % threshAcceleration data
    nBytes = uint32(8 * numel(bus.threshAcceleration));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.threshAcceleration(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized decelerationThreshRatio
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.decelerationThreshRatio) == 1, 'numel(bus.decelerationThreshRatio) must be 1');    % decelerationThreshRatio bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % decelerationThreshRatio signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % decelerationThreshRatio name with prefix 
    if(offset+uint32(2+23 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 23), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 23-1))) = [namePrefixBytes, uint8('decelerationThreshRatio')];
    offset = offset + uint32(numel(namePrefixBytes) + 23);

    % decelerationThreshRatio units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % decelerationThreshRatio data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % decelerationThreshRatio dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.decelerationThreshRatio)), 'uint8');
    offset = offset + uint32(2*1);

    % decelerationThreshRatio data
    nBytes = uint32(8 * numel(bus.decelerationThreshRatio));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.decelerationThreshRatio(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized reaccelerationThreshDelta
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.reaccelerationThreshDelta) == 1, 'numel(bus.reaccelerationThreshDelta) must be 1');    % reaccelerationThreshDelta bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % reaccelerationThreshDelta signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % reaccelerationThreshDelta name with prefix 
    if(offset+uint32(2+25 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 25), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 25-1))) = [namePrefixBytes, uint8('reaccelerationThreshDelta')];
    offset = offset + uint32(numel(namePrefixBytes) + 25);

    % reaccelerationThreshDelta units
    if(offset+uint32(2+8 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(8), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(8-1))) = uint8('mm/sec^2');
    offset = offset + uint32(8);

    % reaccelerationThreshDelta data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % reaccelerationThreshDelta dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.reaccelerationThreshDelta)), 'uint8');
    offset = offset + uint32(2*1);

    % reaccelerationThreshDelta data
    nBytes = uint32(8 * numel(bus.reaccelerationThreshDelta));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.reaccelerationThreshDelta(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized minPeakVelocityTowardsTarget
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.minPeakVelocityTowardsTarget) == 1, 'numel(bus.minPeakVelocityTowardsTarget) must be 1');    % minPeakVelocityTowardsTarget bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % minPeakVelocityTowardsTarget signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % minPeakVelocityTowardsTarget name with prefix 
    if(offset+uint32(2+28 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 28), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 28-1))) = [namePrefixBytes, uint8('minPeakVelocityTowardsTarget')];
    offset = offset + uint32(numel(namePrefixBytes) + 28);

    % minPeakVelocityTowardsTarget units
    if(offset+uint32(2+6 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(6), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(6-1))) = uint8('mm/sec');
    offset = offset + uint32(6);

    % minPeakVelocityTowardsTarget data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % minPeakVelocityTowardsTarget dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.minPeakVelocityTowardsTarget)), 'uint8');
    offset = offset + uint32(2*1);

    % minPeakVelocityTowardsTarget data
    nBytes = uint32(8 * numel(bus.minPeakVelocityTowardsTarget));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.minPeakVelocityTowardsTarget(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized targetHoldJuiceSize
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.targetHoldJuiceSize) == 1, 'numel(bus.targetHoldJuiceSize) must be 1');    % targetHoldJuiceSize bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % targetHoldJuiceSize signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % targetHoldJuiceSize name with prefix 
    if(offset+uint32(2+19 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 19), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 19-1))) = [namePrefixBytes, uint8('targetHoldJuiceSize')];
    offset = offset + uint32(numel(namePrefixBytes) + 19);

    % targetHoldJuiceSize units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % targetHoldJuiceSize data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % targetHoldJuiceSize dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.targetHoldJuiceSize)), 'uint8');
    offset = offset + uint32(2*1);

    % targetHoldJuiceSize data
    nBytes = uint32(8 * numel(bus.targetHoldJuiceSize));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.targetHoldJuiceSize(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized targetHoldJuiceInterval
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.targetHoldJuiceInterval) == 1, 'numel(bus.targetHoldJuiceInterval) must be 1');    % targetHoldJuiceInterval bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % targetHoldJuiceInterval signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % targetHoldJuiceInterval name with prefix 
    if(offset+uint32(2+23 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 23), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 23-1))) = [namePrefixBytes, uint8('targetHoldJuiceInterval')];
    offset = offset + uint32(numel(namePrefixBytes) + 23);

    % targetHoldJuiceInterval units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % targetHoldJuiceInterval data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % targetHoldJuiceInterval dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.targetHoldJuiceInterval)), 'uint8');
    offset = offset + uint32(2*1);

    % targetHoldJuiceInterval data
    nBytes = uint32(8 * numel(bus.targetHoldJuiceInterval));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.targetHoldJuiceInterval(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized allowHandNotSeen
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.allowHandNotSeen) == 1, 'numel(bus.allowHandNotSeen) must be 1');    % allowHandNotSeen bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % allowHandNotSeen signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % allowHandNotSeen name with prefix 
    if(offset+uint32(2+16 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 16), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 16-1))) = [namePrefixBytes, uint8('allowHandNotSeen')];
    offset = offset + uint32(numel(namePrefixBytes) + 16);

    % allowHandNotSeen units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % allowHandNotSeen data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % allowHandNotSeen dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.allowHandNotSeen)), 'uint8');
    offset = offset + uint32(2*1);

    % allowHandNotSeen data
    nBytes = uint32(1 * numel(bus.allowHandNotSeen));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.allowHandNotSeen(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized allowReacquireCenter
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.allowReacquireCenter) == 1, 'numel(bus.allowReacquireCenter) must be 1');    % allowReacquireCenter bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % allowReacquireCenter signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % allowReacquireCenter name with prefix 
    if(offset+uint32(2+20 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 20), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 20-1))) = [namePrefixBytes, uint8('allowReacquireCenter')];
    offset = offset + uint32(numel(namePrefixBytes) + 20);

    % allowReacquireCenter units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % allowReacquireCenter data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % allowReacquireCenter dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.allowReacquireCenter)), 'uint8');
    offset = offset + uint32(2*1);

    % allowReacquireCenter data
    nBytes = uint32(1 * numel(bus.allowReacquireCenter));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.allowReacquireCenter(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized allowReacquireTarget
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.allowReacquireTarget) == 1, 'numel(bus.allowReacquireTarget) must be 1');    % allowReacquireTarget bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % allowReacquireTarget signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % allowReacquireTarget name with prefix 
    if(offset+uint32(2+20 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 20), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 20-1))) = [namePrefixBytes, uint8('allowReacquireTarget')];
    offset = offset + uint32(numel(namePrefixBytes) + 20);

    % allowReacquireTarget units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % allowReacquireTarget data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % allowReacquireTarget dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.allowReacquireTarget)), 'uint8');
    offset = offset + uint32(2*1);

    % allowReacquireTarget data
    nBytes = uint32(1 * numel(bus.allowReacquireTarget));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.allowReacquireTarget(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized frameSkipTime
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.frameSkipTime) == 1, 'numel(bus.frameSkipTime) must be 1');    % frameSkipTime bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % frameSkipTime signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % frameSkipTime name with prefix 
    if(offset+uint32(2+13 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 13), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 13-1))) = [namePrefixBytes, uint8('frameSkipTime')];
    offset = offset + uint32(numel(namePrefixBytes) + 13);

    % frameSkipTime units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % frameSkipTime data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % frameSkipTime dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.frameSkipTime)), 'uint8');
    offset = offset + uint32(2*1);

    % frameSkipTime data
    nBytes = uint32(8 * numel(bus.frameSkipTime));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.frameSkipTime(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized frameIntegrationTime
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.frameIntegrationTime) == 1, 'numel(bus.frameIntegrationTime) must be 1');    % frameIntegrationTime bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % frameIntegrationTime signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % frameIntegrationTime name with prefix 
    if(offset+uint32(2+20 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 20), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 20-1))) = [namePrefixBytes, uint8('frameIntegrationTime')];
    offset = offset + uint32(numel(namePrefixBytes) + 20);

    % frameIntegrationTime units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % frameIntegrationTime data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % frameIntegrationTime dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.frameIntegrationTime)), 'uint8');
    offset = offset + uint32(2*1);

    % frameIntegrationTime data
    nBytes = uint32(8 * numel(bus.frameIntegrationTime));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.frameIntegrationTime(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized imageDecoderTraining
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.imageDecoderTraining) == 1, 'numel(bus.imageDecoderTraining) must be 1');    % imageDecoderTraining bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % imageDecoderTraining signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % imageDecoderTraining name with prefix 
    if(offset+uint32(2+20 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 20), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 20-1))) = [namePrefixBytes, uint8('imageDecoderTraining')];
    offset = offset + uint32(numel(namePrefixBytes) + 20);

    % imageDecoderTraining units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % imageDecoderTraining data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % imageDecoderTraining dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.imageDecoderTraining)), 'uint8');
    offset = offset + uint32(2*1);

    % imageDecoderTraining data
    nBytes = uint32(1 * numel(bus.imageDecoderTraining));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.imageDecoderTraining(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized resetImageDecoder
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.resetImageDecoder) == 1, 'numel(bus.resetImageDecoder) must be 1');    % resetImageDecoder bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % resetImageDecoder signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(5);
    offset = offset + uint32(1);

    % resetImageDecoder name with prefix 
    if(offset+uint32(2+17 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 17), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 17-1))) = [namePrefixBytes, uint8('resetImageDecoder')];
    offset = offset + uint32(numel(namePrefixBytes) + 17);

    % resetImageDecoder units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % resetImageDecoder data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % resetImageDecoder dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.resetImageDecoder)), 'uint8');
    offset = offset + uint32(2*1);

    % resetImageDecoder data
    nBytes = uint32(1 * numel(bus.resetImageDecoder));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.resetImageDecoder(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized imageDecoderDebugDisplayMode
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.imageDecoderDebugDisplayMode) == 1, 'numel(bus.imageDecoderDebugDisplayMode) must be 1');    % imageDecoderDebugDisplayMode bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % imageDecoderDebugDisplayMode signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % imageDecoderDebugDisplayMode name with prefix 
    if(offset+uint32(2+28 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 28), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 28-1))) = [namePrefixBytes, uint8('imageDecoderDebugDisplayMode')];
    offset = offset + uint32(numel(namePrefixBytes) + 28);

    % imageDecoderDebugDisplayMode units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % imageDecoderDebugDisplayMode data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % imageDecoderDebugDisplayMode dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.imageDecoderDebugDisplayMode)), 'uint8');
    offset = offset + uint32(2*1);

    % imageDecoderDebugDisplayMode data
    nBytes = uint32(1 * numel(bus.imageDecoderDebugDisplayMode));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.imageDecoderDebugDisplayMode(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized conditionsToDecode
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.conditionsToDecode) == 4, 'numel(bus.conditionsToDecode) must be 4');    % conditionsToDecode bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % conditionsToDecode signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % conditionsToDecode name with prefix 
    if(offset+uint32(2+18 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 18), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 18-1))) = [namePrefixBytes, uint8('conditionsToDecode')];
    offset = offset + uint32(numel(namePrefixBytes) + 18);

    % conditionsToDecode units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('bool');
    offset = offset + uint32(4);

    % conditionsToDecode data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(9); % data type is logical
    offset = offset + uint32(1);

    % conditionsToDecode dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.conditionsToDecode)), 'uint8');
    offset = offset + uint32(2*1);

    % conditionsToDecode data
    nBytes = uint32(1 * numel(bus.conditionsToDecode));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.conditionsToDecode(:));
    end
    offset = offset + nBytes; %#ok<NASGU>

    valid = uint8(1);
end