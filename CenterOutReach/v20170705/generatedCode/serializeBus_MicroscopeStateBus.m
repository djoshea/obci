function [out, valid] = serializeBus_MicroscopeStateBus(bus, namePrefix)
%#codegen
% DO NOT EDIT: Auto-generated by 
%   BusSerialize.writeSerializeBusCode('MicroscopeStateBus')

    if nargin < 2, namePrefix = uint8(''); end
    namePrefixBytes = uint8(namePrefix(:))';
    valid = uint8(0);
    coder.varsize('out', 1682 + 28*numel(namePrefix));
    outSize = getSerializedBusLength_MicroscopeStateBus(bus, namePrefix);
    assert(outSize <= 1682 + 28*numel(namePrefix));
    out = zeros(outSize, 1, 'uint8');
    offset = uint32(1);

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized saveBase
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.saveBase) <= 200, 'numel(bus.saveBase) exceeds max size of 200');    % saveBase bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);

    % saveBase signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % saveBase name with prefix 
    if(offset+uint32(2+8 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 8), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 8-1))) = [namePrefixBytes, uint8('saveBase')];
    offset = offset + uint32(numel(namePrefixBytes) + 8);

    % saveBase units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('char');
    offset = offset + uint32(4);

    % saveBase data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is char
    offset = offset + uint32(1);

    % saveBase dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.saveBase)), 'uint8');
    offset = offset + uint32(2*1);

    % saveBase data
    nBytes = uint32(1 * numel(bus.saveBase));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.saveBase(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized saveLeaf
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.saveLeaf) <= 200, 'numel(bus.saveLeaf) exceeds max size of 200');    % saveLeaf bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);

    % saveLeaf signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % saveLeaf name with prefix 
    if(offset+uint32(2+8 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 8), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 8-1))) = [namePrefixBytes, uint8('saveLeaf')];
    offset = offset + uint32(numel(namePrefixBytes) + 8);

    % saveLeaf units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('char');
    offset = offset + uint32(4);

    % saveLeaf data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is char
    offset = offset + uint32(1);

    % saveLeaf dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.saveLeaf)), 'uint8');
    offset = offset + uint32(2*1);

    % saveLeaf data
    nBytes = uint32(1 * numel(bus.saveLeaf));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.saveLeaf(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized saveCounter
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.saveCounter) == 1, 'numel(bus.saveCounter) must be 1');    % saveCounter bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % saveCounter signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % saveCounter name with prefix 
    if(offset+uint32(2+11 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 11), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 11-1))) = [namePrefixBytes, uint8('saveCounter')];
    offset = offset + uint32(numel(namePrefixBytes) + 11);

    % saveCounter units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % saveCounter data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(5); % data type is uint16
    offset = offset + uint32(1);

    % saveCounter dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.saveCounter)), 'uint8');
    offset = offset + uint32(2*1);

    % saveCounter data
    nBytes = uint32(2 * numel(bus.saveCounter));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint16(bus.saveCounter(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized objective
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.objective) <= 50, 'numel(bus.objective) exceeds max size of 50');    % objective bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);

    % objective signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % objective name with prefix 
    if(offset+uint32(2+9 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 9), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 9-1))) = [namePrefixBytes, uint8('objective')];
    offset = offset + uint32(numel(namePrefixBytes) + 9);

    % objective units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('char');
    offset = offset + uint32(4);

    % objective data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is char
    offset = offset + uint32(1);

    % objective dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.objective)), 'uint8');
    offset = offset + uint32(2*1);

    % objective data
    nBytes = uint32(1 * numel(bus.objective));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.objective(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized objectiveMag
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.objectiveMag) == 1, 'numel(bus.objectiveMag) must be 1');    % objectiveMag bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % objectiveMag signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % objectiveMag name with prefix 
    if(offset+uint32(2+12 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 12), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 12-1))) = [namePrefixBytes, uint8('objectiveMag')];
    offset = offset + uint32(numel(namePrefixBytes) + 12);

    % objectiveMag units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % objectiveMag data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % objectiveMag dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.objectiveMag)), 'uint8');
    offset = offset + uint32(2*1);

    % objectiveMag data
    nBytes = uint32(8 * numel(bus.objectiveMag));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.objectiveMag(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized objectiveNA
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.objectiveNA) == 1, 'numel(bus.objectiveNA) must be 1');    % objectiveNA bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % objectiveNA signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % objectiveNA name with prefix 
    if(offset+uint32(2+11 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 11), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 11-1))) = [namePrefixBytes, uint8('objectiveNA')];
    offset = offset + uint32(numel(namePrefixBytes) + 11);

    % objectiveNA units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % objectiveNA data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % objectiveNA dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.objectiveNA)), 'uint8');
    offset = offset + uint32(2*1);

    % objectiveNA data
    nBytes = uint32(8 * numel(bus.objectiveNA));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.objectiveNA(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized orbitalPitch
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.orbitalPitch) == 1, 'numel(bus.orbitalPitch) must be 1');    % orbitalPitch bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % orbitalPitch signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % orbitalPitch name with prefix 
    if(offset+uint32(2+12 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 12), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 12-1))) = [namePrefixBytes, uint8('orbitalPitch')];
    offset = offset + uint32(numel(namePrefixBytes) + 12);

    % orbitalPitch units
    if(offset+uint32(2+7 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(7), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(7-1))) = uint8('degrees');
    offset = offset + uint32(7);

    % orbitalPitch data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % orbitalPitch dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.orbitalPitch)), 'uint8');
    offset = offset + uint32(2*1);

    % orbitalPitch data
    nBytes = uint32(8 * numel(bus.orbitalPitch));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.orbitalPitch(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized orbitalYaw
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.orbitalYaw) == 1, 'numel(bus.orbitalYaw) must be 1');    % orbitalYaw bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % orbitalYaw signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % orbitalYaw name with prefix 
    if(offset+uint32(2+10 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 10), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 10-1))) = [namePrefixBytes, uint8('orbitalYaw')];
    offset = offset + uint32(numel(namePrefixBytes) + 10);

    % orbitalYaw units
    if(offset+uint32(2+7 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(7), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(7-1))) = uint8('degrees');
    offset = offset + uint32(7);

    % orbitalYaw data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % orbitalYaw dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.orbitalYaw)), 'uint8');
    offset = offset + uint32(2*1);

    % orbitalYaw data
    nBytes = uint32(8 * numel(bus.orbitalYaw));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.orbitalYaw(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized scopeX
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.scopeX) == 1, 'numel(bus.scopeX) must be 1');    % scopeX bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % scopeX signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % scopeX name with prefix 
    if(offset+uint32(2+6 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 6), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 6-1))) = [namePrefixBytes, uint8('scopeX')];
    offset = offset + uint32(numel(namePrefixBytes) + 6);

    % scopeX units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('um');
    offset = offset + uint32(2);

    % scopeX data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % scopeX dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.scopeX)), 'uint8');
    offset = offset + uint32(2*1);

    % scopeX data
    nBytes = uint32(8 * numel(bus.scopeX));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.scopeX(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized scopeY
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.scopeY) == 1, 'numel(bus.scopeY) must be 1');    % scopeY bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % scopeY signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % scopeY name with prefix 
    if(offset+uint32(2+6 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 6), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 6-1))) = [namePrefixBytes, uint8('scopeY')];
    offset = offset + uint32(numel(namePrefixBytes) + 6);

    % scopeY units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('um');
    offset = offset + uint32(2);

    % scopeY data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % scopeY dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.scopeY)), 'uint8');
    offset = offset + uint32(2*1);

    % scopeY data
    nBytes = uint32(8 * numel(bus.scopeY));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.scopeY(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized scopeZ
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.scopeZ) == 1, 'numel(bus.scopeZ) must be 1');    % scopeZ bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % scopeZ signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % scopeZ name with prefix 
    if(offset+uint32(2+6 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 6), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 6-1))) = [namePrefixBytes, uint8('scopeZ')];
    offset = offset + uint32(numel(namePrefixBytes) + 6);

    % scopeZ units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('um');
    offset = offset + uint32(2);

    % scopeZ data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % scopeZ dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.scopeZ)), 'uint8');
    offset = offset + uint32(2*1);

    % scopeZ data
    nBytes = uint32(8 * numel(bus.scopeZ));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.scopeZ(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized pmtGainGaAsP1
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.pmtGainGaAsP1) == 1, 'numel(bus.pmtGainGaAsP1) must be 1');    % pmtGainGaAsP1 bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % pmtGainGaAsP1 signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % pmtGainGaAsP1 name with prefix 
    if(offset+uint32(2+13 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 13), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 13-1))) = [namePrefixBytes, uint8('pmtGainGaAsP1')];
    offset = offset + uint32(numel(namePrefixBytes) + 13);

    % pmtGainGaAsP1 units
    if(offset+uint32(2+1 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(1), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(1-1))) = uint8('V');
    offset = offset + uint32(1);

    % pmtGainGaAsP1 data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % pmtGainGaAsP1 dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.pmtGainGaAsP1)), 'uint8');
    offset = offset + uint32(2*1);

    % pmtGainGaAsP1 data
    nBytes = uint32(8 * numel(bus.pmtGainGaAsP1));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.pmtGainGaAsP1(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized pmtGainGaAsP2
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.pmtGainGaAsP2) == 1, 'numel(bus.pmtGainGaAsP2) must be 1');    % pmtGainGaAsP2 bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % pmtGainGaAsP2 signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % pmtGainGaAsP2 name with prefix 
    if(offset+uint32(2+13 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 13), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 13-1))) = [namePrefixBytes, uint8('pmtGainGaAsP2')];
    offset = offset + uint32(numel(namePrefixBytes) + 13);

    % pmtGainGaAsP2 units
    if(offset+uint32(2+1 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(1), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(1-1))) = uint8('V');
    offset = offset + uint32(1);

    % pmtGainGaAsP2 data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % pmtGainGaAsP2 dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.pmtGainGaAsP2)), 'uint8');
    offset = offset + uint32(2*1);

    % pmtGainGaAsP2 data
    nBytes = uint32(8 * numel(bus.pmtGainGaAsP2));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.pmtGainGaAsP2(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized pmtGainLightGuide
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.pmtGainLightGuide) == 1, 'numel(bus.pmtGainLightGuide) must be 1');    % pmtGainLightGuide bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % pmtGainLightGuide signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % pmtGainLightGuide name with prefix 
    if(offset+uint32(2+17 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 17), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 17-1))) = [namePrefixBytes, uint8('pmtGainLightGuide')];
    offset = offset + uint32(numel(namePrefixBytes) + 17);

    % pmtGainLightGuide units
    if(offset+uint32(2+1 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(1), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(1-1))) = uint8('V');
    offset = offset + uint32(1);

    % pmtGainLightGuide data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % pmtGainLightGuide dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.pmtGainLightGuide)), 'uint8');
    offset = offset + uint32(2*1);

    % pmtGainLightGuide data
    nBytes = uint32(8 * numel(bus.pmtGainLightGuide));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.pmtGainLightGuide(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized pockels
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.pockels) == 1, 'numel(bus.pockels) must be 1');    % pockels bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % pockels signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % pockels name with prefix 
    if(offset+uint32(2+7 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 7), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 7-1))) = [namePrefixBytes, uint8('pockels')];
    offset = offset + uint32(numel(namePrefixBytes) + 7);

    % pockels units
    if(offset+uint32(2+1 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(1), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(1-1))) = uint8('V');
    offset = offset + uint32(1);

    % pockels data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % pockels dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.pockels)), 'uint8');
    offset = offset + uint32(2*1);

    % pockels data
    nBytes = uint32(8 * numel(bus.pockels));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.pockels(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized pixelSizeX
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.pixelSizeX) == 1, 'numel(bus.pixelSizeX) must be 1');    % pixelSizeX bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % pixelSizeX signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % pixelSizeX name with prefix 
    if(offset+uint32(2+10 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 10), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 10-1))) = [namePrefixBytes, uint8('pixelSizeX')];
    offset = offset + uint32(numel(namePrefixBytes) + 10);

    % pixelSizeX units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('um');
    offset = offset + uint32(2);

    % pixelSizeX data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % pixelSizeX dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.pixelSizeX)), 'uint8');
    offset = offset + uint32(2*1);

    % pixelSizeX data
    nBytes = uint32(8 * numel(bus.pixelSizeX));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.pixelSizeX(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized pixelSizeY
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.pixelSizeY) == 1, 'numel(bus.pixelSizeY) must be 1');    % pixelSizeY bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % pixelSizeY signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % pixelSizeY name with prefix 
    if(offset+uint32(2+10 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 10), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 10-1))) = [namePrefixBytes, uint8('pixelSizeY')];
    offset = offset + uint32(numel(namePrefixBytes) + 10);

    % pixelSizeY units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('um');
    offset = offset + uint32(2);

    % pixelSizeY data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % pixelSizeY dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.pixelSizeY)), 'uint8');
    offset = offset + uint32(2*1);

    % pixelSizeY data
    nBytes = uint32(8 * numel(bus.pixelSizeY));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.pixelSizeY(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized pixelsX
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.pixelsX) == 1, 'numel(bus.pixelsX) must be 1');    % pixelsX bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % pixelsX signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % pixelsX name with prefix 
    if(offset+uint32(2+7 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 7), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 7-1))) = [namePrefixBytes, uint8('pixelsX')];
    offset = offset + uint32(numel(namePrefixBytes) + 7);

    % pixelsX units
    if(offset+uint32(2+6 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(6), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(6-1))) = uint8('pixels');
    offset = offset + uint32(6);

    % pixelsX data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % pixelsX dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.pixelsX)), 'uint8');
    offset = offset + uint32(2*1);

    % pixelsX data
    nBytes = uint32(8 * numel(bus.pixelsX));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.pixelsX(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized pixelsY
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.pixelsY) == 1, 'numel(bus.pixelsY) must be 1');    % pixelsY bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % pixelsY signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % pixelsY name with prefix 
    if(offset+uint32(2+7 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 7), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 7-1))) = [namePrefixBytes, uint8('pixelsY')];
    offset = offset + uint32(numel(namePrefixBytes) + 7);

    % pixelsY units
    if(offset+uint32(2+6 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(6), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(6-1))) = uint8('pixels');
    offset = offset + uint32(6);

    % pixelsY data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % pixelsY dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.pixelsY)), 'uint8');
    offset = offset + uint32(2*1);

    % pixelsY data
    nBytes = uint32(8 * numel(bus.pixelsY));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.pixelsY(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized galvoMode
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.galvoMode) == 1, 'numel(bus.galvoMode) must be 1');    % galvoMode bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(0);
    offset = offset + uint32(1);

    % galvoMode signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % galvoMode name with prefix 
    if(offset+uint32(2+9 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 9), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 9-1))) = [namePrefixBytes, uint8('galvoMode')];
    offset = offset + uint32(numel(namePrefixBytes) + 9);

    % galvoMode units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('enum');
    offset = offset + uint32(4);

    % galvoMode data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is GalvoMode
    offset = offset + uint32(1);

    % galvoMode dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    % converting enum type GalvoMode to string
    coder.varsize('enumAsStr_galvoMode', 8);
    enumAsStr_galvoMode = zeros(0, 1, 'uint8');
    for iEnum = 1:numel(bus.galvoMode)
        enumAsStr_galvoMode = [enumAsStr_galvoMode; uint8(enumToString_GalvoMode(bus.galvoMode(iEnum)))']; %#ok<AGROW>
        if iEnum < numel(bus.galvoMode)
            enumAsStr_galvoMode = [enumAsStr_galvoMode; uint8(';')]; %#ok<AGROW>
        end
    end
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(enumAsStr_galvoMode)), 'uint8');
    offset = offset + uint32(2*1);

    % galvoMode data
    nBytes = uint32(numel(enumAsStr_galvoMode));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(enumAsStr_galvoMode(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized laserWavelength
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.laserWavelength) == 1, 'numel(bus.laserWavelength) must be 1');    % laserWavelength bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % laserWavelength signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % laserWavelength name with prefix 
    if(offset+uint32(2+15 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 15), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 15-1))) = [namePrefixBytes, uint8('laserWavelength')];
    offset = offset + uint32(numel(namePrefixBytes) + 15);

    % laserWavelength units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('nm');
    offset = offset + uint32(2);

    % laserWavelength data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % laserWavelength dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.laserWavelength)), 'uint8');
    offset = offset + uint32(2*1);

    % laserWavelength data
    nBytes = uint32(8 * numel(bus.laserWavelength));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.laserWavelength(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized dwellTime
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.dwellTime) == 1, 'numel(bus.dwellTime) must be 1');    % dwellTime bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % dwellTime signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % dwellTime name with prefix 
    if(offset+uint32(2+9 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 9), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 9-1))) = [namePrefixBytes, uint8('dwellTime')];
    offset = offset + uint32(numel(namePrefixBytes) + 9);

    % dwellTime units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('us');
    offset = offset + uint32(2);

    % dwellTime data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % dwellTime dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.dwellTime)), 'uint8');
    offset = offset + uint32(2*1);

    % dwellTime data
    nBytes = uint32(8 * numel(bus.dwellTime));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.dwellTime(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized frameRate
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.frameRate) == 1, 'numel(bus.frameRate) must be 1');    % frameRate bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % frameRate signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % frameRate name with prefix 
    if(offset+uint32(2+9 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 9), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 9-1))) = [namePrefixBytes, uint8('frameRate')];
    offset = offset + uint32(numel(namePrefixBytes) + 9);

    % frameRate units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('Hz');
    offset = offset + uint32(2);

    % frameRate data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(0); % data type is double
    offset = offset + uint32(1);

    % frameRate dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.frameRate)), 'uint8');
    offset = offset + uint32(2*1);

    % frameRate data
    nBytes = uint32(8 * numel(bus.frameRate));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(double(bus.frameRate(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized cameraIsAcquiring
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.cameraIsAcquiring) == 1, 'numel(bus.cameraIsAcquiring) must be 1');    % cameraIsAcquiring bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % cameraIsAcquiring signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % cameraIsAcquiring name with prefix 
    if(offset+uint32(2+17 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 17), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 17-1))) = [namePrefixBytes, uint8('cameraIsAcquiring')];
    offset = offset + uint32(numel(namePrefixBytes) + 17);

    % cameraIsAcquiring units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % cameraIsAcquiring data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % cameraIsAcquiring dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.cameraIsAcquiring)), 'uint8');
    offset = offset + uint32(2*1);

    % cameraIsAcquiring data
    nBytes = uint32(1 * numel(bus.cameraIsAcquiring));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.cameraIsAcquiring(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized cameraRelativePath
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.cameraRelativePath) <= 200, 'numel(bus.cameraRelativePath) exceeds max size of 200');    % cameraRelativePath bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);

    % cameraRelativePath signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % cameraRelativePath name with prefix 
    if(offset+uint32(2+18 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 18), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 18-1))) = [namePrefixBytes, uint8('cameraRelativePath')];
    offset = offset + uint32(numel(namePrefixBytes) + 18);

    % cameraRelativePath units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('char');
    offset = offset + uint32(4);

    % cameraRelativePath data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is char
    offset = offset + uint32(1);

    % cameraRelativePath dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.cameraRelativePath)), 'uint8');
    offset = offset + uint32(2*1);

    % cameraRelativePath data
    nBytes = uint32(1 * numel(bus.cameraRelativePath));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.cameraRelativePath(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized cameraFileShort
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.cameraFileShort) <= 200, 'numel(bus.cameraFileShort) exceeds max size of 200');    % cameraFileShort bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);

    % cameraFileShort signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % cameraFileShort name with prefix 
    if(offset+uint32(2+15 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 15), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 15-1))) = [namePrefixBytes, uint8('cameraFileShort')];
    offset = offset + uint32(numel(namePrefixBytes) + 15);

    % cameraFileShort units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('char');
    offset = offset + uint32(4);

    % cameraFileShort data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is char
    offset = offset + uint32(1);

    % cameraFileShort dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.cameraFileShort)), 'uint8');
    offset = offset + uint32(2*1);

    % cameraFileShort data
    nBytes = uint32(1 * numel(bus.cameraFileShort));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.cameraFileShort(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized cameraFileCounter
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.cameraFileCounter) == 1, 'numel(bus.cameraFileCounter) must be 1');    % cameraFileCounter bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % cameraFileCounter signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % cameraFileCounter name with prefix 
    if(offset+uint32(2+17 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 17), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 17-1))) = [namePrefixBytes, uint8('cameraFileCounter')];
    offset = offset + uint32(numel(namePrefixBytes) + 17);

    % cameraFileCounter units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % cameraFileCounter data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(5); % data type is uint16
    offset = offset + uint32(1);

    % cameraFileCounter dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.cameraFileCounter)), 'uint8');
    offset = offset + uint32(2*1);

    % cameraFileCounter data
    nBytes = uint32(2 * numel(bus.cameraFileCounter));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(uint16(bus.cameraFileCounter(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized mOEGLedMode
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.mOEGLedMode) == 1, 'numel(bus.mOEGLedMode) must be 1');    % mOEGLedMode bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(0);
    offset = offset + uint32(1);

    % mOEGLedMode signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % mOEGLedMode name with prefix 
    if(offset+uint32(2+11 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 11), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 11-1))) = [namePrefixBytes, uint8('mOEGLedMode')];
    offset = offset + uint32(numel(namePrefixBytes) + 11);

    % mOEGLedMode units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('enum');
    offset = offset + uint32(4);

    % mOEGLedMode data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is LedMode
    offset = offset + uint32(1);

    % mOEGLedMode dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    % converting enum type LedMode to string
    coder.varsize('enumAsStr_mOEGLedMode', 18);
    enumAsStr_mOEGLedMode = zeros(0, 1, 'uint8');
    for iEnum = 1:numel(bus.mOEGLedMode)
        enumAsStr_mOEGLedMode = [enumAsStr_mOEGLedMode; uint8(enumToString_LedMode(bus.mOEGLedMode(iEnum)))']; %#ok<AGROW>
        if iEnum < numel(bus.mOEGLedMode)
            enumAsStr_mOEGLedMode = [enumAsStr_mOEGLedMode; uint8(';')]; %#ok<AGROW>
        end
    end
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(enumAsStr_mOEGLedMode)), 'uint8');
    offset = offset + uint32(2*1);

    % mOEGLedMode data
    nBytes = uint32(numel(enumAsStr_mOEGLedMode));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(enumAsStr_mOEGLedMode(:));
    end
    offset = offset + nBytes; %#ok<NASGU>

    valid = uint8(1);
end