function [out, valid] = serializeBusWithDataLoggerHeader_NoteBus(bus, groupType, groupName, timestamp, namePrefix)
%#codegen
% DO NOT EDIT: Auto-generated by 
%   BusSerialize.writeSerializeBusCode('NoteBus')

    if nargin < 5, namePrefix = uint8(''); end
    namePrefixBytes = uint8(namePrefix(:))';
    valid = uint8(0);
    headerLength = uint32(BusSerialize.computeDataLoggerHeaderLength(uint8([namePrefixBytes, groupName])));
    coder.varsize('out', 50055 + 2*numel(namePrefix) + headerLength);
    outSize = headerLength + getSerializedBusLength_NoteBus(bus, namePrefix);
    assert(outSize <= headerLength + 50055 + 2*numel(namePrefix));
    out = zeros(outSize, 1, 'uint8');
    offset = uint32(1);

    % Serialize data logger header
    header = BusSerialize.serializeDataLoggerHeader(groupType, uint8([namePrefixBytes, groupName]), uint32(3503237069), uint16(2), timestamp);
    out(1:headerLength) = uint8(header);
    offset = offset + headerLength;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize fixed-sized noteType
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.noteType) == 1, 'numel(bus.noteType) must be 1');    % noteType bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(0);
    offset = offset + uint32(1);

    % noteType signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % noteType name with prefix 
    if(offset+uint32(2+8 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 8), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 8-1))) = [namePrefixBytes, uint8('noteType')];
    offset = offset + uint32(numel(namePrefixBytes) + 8);

    % noteType units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('enum');
    offset = offset + uint32(4);

    % noteType data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is NoteType
    offset = offset + uint32(1);

    % noteType dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    % converting enum type NoteType to string
    coder.varsize('enumAsStr_noteType', 15);
    enumAsStr_noteType = zeros(0, 1, 'uint8');
    for iEnum = 1:numel(bus.noteType)
        enumAsStr_noteType = [enumAsStr_noteType; uint8(enumToString_NoteType(bus.noteType(iEnum)))']; %#ok<AGROW>
        if iEnum < numel(bus.noteType)
            enumAsStr_noteType = [enumAsStr_noteType; uint8(';')]; %#ok<AGROW>
        end
    end
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(enumAsStr_noteType)), 'uint8');
    offset = offset + uint32(2*1);

    % noteType data
    nBytes = uint32(numel(enumAsStr_noteType));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(enumAsStr_noteType(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized note
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.note) <= 50000, 'numel(bus.note) exceeds max size of 50000');    % note bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);

    % note signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(4);
    offset = offset + uint32(1);

    % note name with prefix 
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 4-1))) = [namePrefixBytes, uint8('note')];
    offset = offset + uint32(numel(namePrefixBytes) + 4);

    % note units
    if(offset+uint32(2+4 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(4), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(4-1))) = uint8('char');
    offset = offset + uint32(4);

    % note data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(8); % data type is char
    offset = offset + uint32(1);

    % note dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.note)), 'uint8');
    offset = offset + uint32(2*1);

    % note data
    nBytes = uint32(1 * numel(bus.note));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.note(:));
    end
    offset = offset + nBytes; %#ok<NASGU>

    valid = uint8(1);
end